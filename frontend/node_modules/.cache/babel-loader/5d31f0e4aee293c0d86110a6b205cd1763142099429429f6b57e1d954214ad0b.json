{"ast":null,"code":"// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst color = require('color');\nconst is = require('./is');\n\n/**\n * Rotate the output image by either an explicit angle\n * or auto-orient based on the EXIF `Orientation` tag.\n *\n * If an angle is provided, it is converted to a valid positive degree rotation.\n * For example, `-450` will produce a 270deg rotation.\n *\n * When rotating by an angle other than a multiple of 90,\n * the background colour can be provided with the `background` option.\n *\n * If no angle is provided, it is determined from the EXIF data.\n * Mirroring is supported and may infer the use of a flip operation.\n *\n * The use of `rotate` implies the removal of the EXIF `Orientation` tag, if any.\n *\n * Only one rotation can occur per pipeline.\n * Previous calls to `rotate` in the same pipeline will be ignored.\n *\n * Method order is important when rotating, resizing and/or extracting regions,\n * for example `.rotate(x).extract(y)` will produce a different result to `.extract(y).rotate(x)`.\n *\n * @example\n * const pipeline = sharp()\n *   .rotate()\n *   .resize(null, 200)\n *   .toBuffer(function (err, outputBuffer, info) {\n *     // outputBuffer contains 200px high JPEG image data,\n *     // auto-rotated using EXIF Orientation tag\n *     // info.width and info.height contain the dimensions of the resized image\n *   });\n * readableStream.pipe(pipeline);\n *\n * @example\n * const rotateThenResize = await sharp(input)\n *   .rotate(90)\n *   .resize({ width: 16, height: 8, fit: 'fill' })\n *   .toBuffer();\n * const resizeThenRotate = await sharp(input)\n *   .resize({ width: 16, height: 8, fit: 'fill' })\n *   .rotate(90)\n *   .toBuffer();\n *\n * @param {number} [angle=auto] angle of rotation.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {string|Object} [options.background=\"#000000\"] parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction rotate(angle, options) {\n  if (this.options.useExifOrientation || this.options.angle || this.options.rotationAngle) {\n    this.options.debuglog('ignoring previous rotate options');\n  }\n  if (!is.defined(angle)) {\n    this.options.useExifOrientation = true;\n  } else if (is.integer(angle) && !(angle % 90)) {\n    this.options.angle = angle;\n  } else if (is.number(angle)) {\n    this.options.rotationAngle = angle;\n    if (is.object(options) && options.background) {\n      const backgroundColour = color(options.background);\n      this.options.rotationBackground = [backgroundColour.red(), backgroundColour.green(), backgroundColour.blue(), Math.round(backgroundColour.alpha() * 255)];\n    }\n  } else {\n    throw is.invalidParameterError('angle', 'numeric', angle);\n  }\n  return this;\n}\n\n/**\n * Flip the image about the vertical Y axis. This always occurs before rotation, if any.\n * The use of `flip` implies the removal of the EXIF `Orientation` tag, if any.\n *\n * @example\n * const output = await sharp(input).flip().toBuffer();\n *\n * @param {Boolean} [flip=true]\n * @returns {Sharp}\n */\nfunction flip(flip) {\n  this.options.flip = is.bool(flip) ? flip : true;\n  return this;\n}\n\n/**\n * Flop the image about the horizontal X axis. This always occurs before rotation, if any.\n * The use of `flop` implies the removal of the EXIF `Orientation` tag, if any.\n *\n * @example\n * const output = await sharp(input).flop().toBuffer();\n *\n * @param {Boolean} [flop=true]\n * @returns {Sharp}\n */\nfunction flop(flop) {\n  this.options.flop = is.bool(flop) ? flop : true;\n  return this;\n}\n\n/**\n * Perform an affine transform on an image. This operation will always occur after resizing, extraction and rotation, if any.\n *\n * You must provide an array of length 4 or a 2x2 affine transformation matrix.\n * By default, new pixels are filled with a black background. You can provide a background color with the `background` option.\n * A particular interpolator may also be specified. Set the `interpolator` option to an attribute of the `sharp.interpolators` Object e.g. `sharp.interpolators.nohalo`.\n *\n * In the case of a 2x2 matrix, the transform is:\n * - X = `matrix[0, 0]` \\* (x + `idx`) + `matrix[0, 1]` \\* (y + `idy`) + `odx`\n * - Y = `matrix[1, 0]` \\* (x + `idx`) + `matrix[1, 1]` \\* (y + `idy`) + `ody`\n *\n * where:\n * - x and y are the coordinates in input image.\n * - X and Y are the coordinates in output image.\n * - (0,0) is the upper left corner.\n *\n * @since 0.27.0\n *\n * @example\n * const pipeline = sharp()\n *   .affine([[1, 0.3], [0.1, 0.7]], {\n *      background: 'white',\n *      interpolator: sharp.interpolators.nohalo\n *   })\n *   .toBuffer((err, outputBuffer, info) => {\n *      // outputBuffer contains the transformed image\n *      // info.width and info.height contain the new dimensions\n *   });\n *\n * inputStream\n *   .pipe(pipeline);\n *\n * @param {Array<Array<number>>|Array<number>} matrix - affine transformation matrix\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {String|Object} [options.background=\"#000000\"] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Number} [options.idx=0] - input horizontal offset\n * @param {Number} [options.idy=0] - input vertical offset\n * @param {Number} [options.odx=0] - output horizontal offset\n * @param {Number} [options.ody=0] - output vertical offset\n * @param {String} [options.interpolator=sharp.interpolators.bicubic] - interpolator\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction affine(matrix, options) {\n  const flatMatrix = [].concat(...matrix);\n  if (flatMatrix.length === 4 && flatMatrix.every(is.number)) {\n    this.options.affineMatrix = flatMatrix;\n  } else {\n    throw is.invalidParameterError('matrix', '1x4 or 2x2 array', matrix);\n  }\n  if (is.defined(options)) {\n    if (is.object(options)) {\n      this._setBackgroundColourOption('affineBackground', options.background);\n      if (is.defined(options.idx)) {\n        if (is.number(options.idx)) {\n          this.options.affineIdx = options.idx;\n        } else {\n          throw is.invalidParameterError('options.idx', 'number', options.idx);\n        }\n      }\n      if (is.defined(options.idy)) {\n        if (is.number(options.idy)) {\n          this.options.affineIdy = options.idy;\n        } else {\n          throw is.invalidParameterError('options.idy', 'number', options.idy);\n        }\n      }\n      if (is.defined(options.odx)) {\n        if (is.number(options.odx)) {\n          this.options.affineOdx = options.odx;\n        } else {\n          throw is.invalidParameterError('options.odx', 'number', options.odx);\n        }\n      }\n      if (is.defined(options.ody)) {\n        if (is.number(options.ody)) {\n          this.options.affineOdy = options.ody;\n        } else {\n          throw is.invalidParameterError('options.ody', 'number', options.ody);\n        }\n      }\n      if (is.defined(options.interpolator)) {\n        if (is.inArray(options.interpolator, Object.values(this.constructor.interpolators))) {\n          this.options.affineInterpolator = options.interpolator;\n        } else {\n          throw is.invalidParameterError('options.interpolator', 'valid interpolator name', options.interpolator);\n        }\n      }\n    } else {\n      throw is.invalidParameterError('options', 'object', options);\n    }\n  }\n  return this;\n}\n\n/**\n * Sharpen the image.\n *\n * When used without parameters, performs a fast, mild sharpen of the output image.\n *\n * When a `sigma` is provided, performs a slower, more accurate sharpen of the L channel in the LAB colour space.\n * Fine-grained control over the level of sharpening in \"flat\" (m1) and \"jagged\" (m2) areas is available.\n *\n * See {@link https://www.libvips.org/API/current/libvips-convolution.html#vips-sharpen|libvips sharpen} operation.\n *\n * @example\n * const data = await sharp(input).sharpen().toBuffer();\n *\n * @example\n * const data = await sharp(input).sharpen({ sigma: 2 }).toBuffer();\n *\n * @example\n * const data = await sharp(input)\n *   .sharpen({\n *     sigma: 2,\n *     m1: 0,\n *     m2: 3,\n *     x1: 3,\n *     y2: 15,\n *     y3: 15,\n *   })\n *   .toBuffer();\n *\n * @param {Object|number} [options] - if present, is an Object with attributes\n * @param {number} [options.sigma] - the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`, between 0.000001 and 10\n * @param {number} [options.m1=1.0] - the level of sharpening to apply to \"flat\" areas, between 0 and 1000000\n * @param {number} [options.m2=2.0] - the level of sharpening to apply to \"jagged\" areas, between 0 and 1000000\n * @param {number} [options.x1=2.0] - threshold between \"flat\" and \"jagged\", between 0 and 1000000\n * @param {number} [options.y2=10.0] - maximum amount of brightening, between 0 and 1000000\n * @param {number} [options.y3=20.0] - maximum amount of darkening, between 0 and 1000000\n * @param {number} [flat] - (deprecated) see `options.m1`.\n * @param {number} [jagged] - (deprecated) see `options.m2`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction sharpen(options, flat, jagged) {\n  if (!is.defined(options)) {\n    // No arguments: default to mild sharpen\n    this.options.sharpenSigma = -1;\n  } else if (is.bool(options)) {\n    // Deprecated boolean argument: apply mild sharpen?\n    this.options.sharpenSigma = options ? -1 : 0;\n  } else if (is.number(options) && is.inRange(options, 0.01, 10000)) {\n    // Deprecated numeric argument: specific sigma\n    this.options.sharpenSigma = options;\n    // Deprecated control over flat areas\n    if (is.defined(flat)) {\n      if (is.number(flat) && is.inRange(flat, 0, 10000)) {\n        this.options.sharpenM1 = flat;\n      } else {\n        throw is.invalidParameterError('flat', 'number between 0 and 10000', flat);\n      }\n    }\n    // Deprecated control over jagged areas\n    if (is.defined(jagged)) {\n      if (is.number(jagged) && is.inRange(jagged, 0, 10000)) {\n        this.options.sharpenM2 = jagged;\n      } else {\n        throw is.invalidParameterError('jagged', 'number between 0 and 10000', jagged);\n      }\n    }\n  } else if (is.plainObject(options)) {\n    if (is.number(options.sigma) && is.inRange(options.sigma, 0.000001, 10)) {\n      this.options.sharpenSigma = options.sigma;\n    } else {\n      throw is.invalidParameterError('options.sigma', 'number between 0.000001 and 10', options.sigma);\n    }\n    if (is.defined(options.m1)) {\n      if (is.number(options.m1) && is.inRange(options.m1, 0, 1000000)) {\n        this.options.sharpenM1 = options.m1;\n      } else {\n        throw is.invalidParameterError('options.m1', 'number between 0 and 1000000', options.m1);\n      }\n    }\n    if (is.defined(options.m2)) {\n      if (is.number(options.m2) && is.inRange(options.m2, 0, 1000000)) {\n        this.options.sharpenM2 = options.m2;\n      } else {\n        throw is.invalidParameterError('options.m2', 'number between 0 and 1000000', options.m2);\n      }\n    }\n    if (is.defined(options.x1)) {\n      if (is.number(options.x1) && is.inRange(options.x1, 0, 1000000)) {\n        this.options.sharpenX1 = options.x1;\n      } else {\n        throw is.invalidParameterError('options.x1', 'number between 0 and 1000000', options.x1);\n      }\n    }\n    if (is.defined(options.y2)) {\n      if (is.number(options.y2) && is.inRange(options.y2, 0, 1000000)) {\n        this.options.sharpenY2 = options.y2;\n      } else {\n        throw is.invalidParameterError('options.y2', 'number between 0 and 1000000', options.y2);\n      }\n    }\n    if (is.defined(options.y3)) {\n      if (is.number(options.y3) && is.inRange(options.y3, 0, 1000000)) {\n        this.options.sharpenY3 = options.y3;\n      } else {\n        throw is.invalidParameterError('options.y3', 'number between 0 and 1000000', options.y3);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('sigma', 'number between 0.01 and 10000', options);\n  }\n  return this;\n}\n\n/**\n * Apply median filter.\n * When used without parameters the default window is 3x3.\n *\n * @example\n * const output = await sharp(input).median().toBuffer();\n *\n * @example\n * const output = await sharp(input).median(5).toBuffer();\n *\n * @param {number} [size=3] square mask size: size x size\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction median(size) {\n  if (!is.defined(size)) {\n    // No arguments: default to 3x3\n    this.options.medianSize = 3;\n  } else if (is.integer(size) && is.inRange(size, 1, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.medianSize = size;\n  } else {\n    throw is.invalidParameterError('size', 'integer between 1 and 1000', size);\n  }\n  return this;\n}\n\n/**\n * Blur the image.\n *\n * When used without parameters, performs a fast 3x3 box blur (equivalent to a box linear filter).\n *\n * When a `sigma` is provided, performs a slower, more accurate Gaussian blur.\n *\n * @example\n * const boxBlurred = await sharp(input)\n *   .blur()\n *   .toBuffer();\n *\n * @example\n * const gaussianBlurred = await sharp(input)\n *   .blur(5)\n *   .toBuffer();\n *\n * @param {number} [sigma] a value between 0.3 and 1000 representing the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction blur(sigma) {\n  if (!is.defined(sigma)) {\n    // No arguments: default to mild blur\n    this.options.blurSigma = -1;\n  } else if (is.bool(sigma)) {\n    // Boolean argument: apply mild blur?\n    this.options.blurSigma = sigma ? -1 : 0;\n  } else if (is.number(sigma) && is.inRange(sigma, 0.3, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.blurSigma = sigma;\n  } else {\n    throw is.invalidParameterError('sigma', 'number between 0.3 and 1000', sigma);\n  }\n  return this;\n}\n\n/**\n * Merge alpha transparency channel, if any, with a background, then remove the alpha channel.\n *\n * See also {@link /api-channel#removealpha|removeAlpha}.\n *\n * @example\n * await sharp(rgbaInput)\n *   .flatten({ background: '#F0A703' })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {string|Object} [options.background={r: 0, g: 0, b: 0}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black.\n * @returns {Sharp}\n */\nfunction flatten(options) {\n  this.options.flatten = is.bool(options) ? options : true;\n  if (is.object(options)) {\n    this._setBackgroundColourOption('flattenBackground', options.background);\n  }\n  return this;\n}\n\n/**\n * Ensure the image has an alpha channel\n * with all white pixel values made fully transparent.\n *\n * Existing alpha channel values for non-white pixels remain unchanged.\n *\n * This feature is experimental and the API may change.\n *\n * @since 0.32.1\n *\n * @example\n * await sharp(rgbInput)\n *   .unflatten()\n *   .toBuffer();\n *\n * @example\n * await sharp(rgbInput)\n *   .threshold(128, { grayscale: false }) // converter bright pixels to white\n *   .unflatten()\n *   .toBuffer();\n */\nfunction unflatten() {\n  this.options.unflatten = true;\n  return this;\n}\n\n/**\n * Apply a gamma correction by reducing the encoding (darken) pre-resize at a factor of `1/gamma`\n * then increasing the encoding (brighten) post-resize at a factor of `gamma`.\n * This can improve the perceived brightness of a resized image in non-linear colour spaces.\n * JPEG and WebP input images will not take advantage of the shrink-on-load performance optimisation\n * when applying a gamma correction.\n *\n * Supply a second argument to use a different output gamma value, otherwise the first value is used in both cases.\n *\n * @param {number} [gamma=2.2] value between 1.0 and 3.0.\n * @param {number} [gammaOut] value between 1.0 and 3.0. (optional, defaults to same as `gamma`)\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction gamma(gamma, gammaOut) {\n  if (!is.defined(gamma)) {\n    // Default gamma correction of 2.2 (sRGB)\n    this.options.gamma = 2.2;\n  } else if (is.number(gamma) && is.inRange(gamma, 1, 3)) {\n    this.options.gamma = gamma;\n  } else {\n    throw is.invalidParameterError('gamma', 'number between 1.0 and 3.0', gamma);\n  }\n  if (!is.defined(gammaOut)) {\n    // Default gamma correction for output is same as input\n    this.options.gammaOut = this.options.gamma;\n  } else if (is.number(gammaOut) && is.inRange(gammaOut, 1, 3)) {\n    this.options.gammaOut = gammaOut;\n  } else {\n    throw is.invalidParameterError('gammaOut', 'number between 1.0 and 3.0', gammaOut);\n  }\n  return this;\n}\n\n/**\n * Produce the \"negative\" of the image.\n *\n * @example\n * const output = await sharp(input)\n *   .negate()\n *   .toBuffer();\n *\n * @example\n * const output = await sharp(input)\n *   .negate({ alpha: false })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {Boolean} [options.alpha=true] Whether or not to negate any alpha channel\n * @returns {Sharp}\n */\nfunction negate(options) {\n  this.options.negate = is.bool(options) ? options : true;\n  if (is.plainObject(options) && 'alpha' in options) {\n    if (!is.bool(options.alpha)) {\n      throw is.invalidParameterError('alpha', 'should be boolean value', options.alpha);\n    } else {\n      this.options.negateAlpha = options.alpha;\n    }\n  }\n  return this;\n}\n\n/**\n * Enhance output image contrast by stretching its luminance to cover a full dynamic range.\n *\n * Uses a histogram-based approach, taking a default range of 1% to 99% to reduce sensitivity to noise at the extremes.\n *\n * Luminance values below the `lower` percentile will be underexposed by clipping to zero.\n * Luminance values above the `upper` percentile will be overexposed by clipping to the max pixel value.\n *\n * @example\n * const output = await sharp(input)\n *   .normalise()\n *   .toBuffer();\n *\n * @example\n * const output = await sharp(input)\n *   .normalise({ lower: 0, upper: 100 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.lower=1] - Percentile below which luminance values will be underexposed.\n * @param {number} [options.upper=99] - Percentile above which luminance values will be overexposed.\n * @returns {Sharp}\n */\nfunction normalise(options) {\n  if (is.plainObject(options)) {\n    if (is.defined(options.lower)) {\n      if (is.number(options.lower) && is.inRange(options.lower, 0, 99)) {\n        this.options.normaliseLower = options.lower;\n      } else {\n        throw is.invalidParameterError('lower', 'number between 0 and 99', options.lower);\n      }\n    }\n    if (is.defined(options.upper)) {\n      if (is.number(options.upper) && is.inRange(options.upper, 1, 100)) {\n        this.options.normaliseUpper = options.upper;\n      } else {\n        throw is.invalidParameterError('upper', 'number between 1 and 100', options.upper);\n      }\n    }\n  }\n  if (this.options.normaliseLower >= this.options.normaliseUpper) {\n    throw is.invalidParameterError('range', 'lower to be less than upper', `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`);\n  }\n  this.options.normalise = true;\n  return this;\n}\n\n/**\n * Alternative spelling of normalise.\n *\n * @example\n * const output = await sharp(input)\n *   .normalize()\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.lower=1] - Percentile below which luminance values will be underexposed.\n * @param {number} [options.upper=99] - Percentile above which luminance values will be overexposed.\n * @returns {Sharp}\n */\nfunction normalize(options) {\n  return this.normalise(options);\n}\n\n/**\n * Perform contrast limiting adaptive histogram equalization\n * {@link https://en.wikipedia.org/wiki/Adaptive_histogram_equalization#Contrast_Limited_AHE|CLAHE}.\n *\n * This will, in general, enhance the clarity of the image by bringing out darker details.\n *\n * @since 0.28.3\n *\n * @example\n * const output = await sharp(input)\n *   .clahe({\n *     width: 3,\n *     height: 3,\n *   })\n *   .toBuffer();\n *\n * @param {Object} options\n * @param {number} options.width - Integral width of the search window, in pixels.\n * @param {number} options.height - Integral height of the search window, in pixels.\n * @param {number} [options.maxSlope=3] - Integral level of brightening, between 0 and 100, where 0 disables contrast limiting.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction clahe(options) {\n  if (is.plainObject(options)) {\n    if (is.integer(options.width) && options.width > 0) {\n      this.options.claheWidth = options.width;\n    } else {\n      throw is.invalidParameterError('width', 'integer greater than zero', options.width);\n    }\n    if (is.integer(options.height) && options.height > 0) {\n      this.options.claheHeight = options.height;\n    } else {\n      throw is.invalidParameterError('height', 'integer greater than zero', options.height);\n    }\n    if (is.defined(options.maxSlope)) {\n      if (is.integer(options.maxSlope) && is.inRange(options.maxSlope, 0, 100)) {\n        this.options.claheMaxSlope = options.maxSlope;\n      } else {\n        throw is.invalidParameterError('maxSlope', 'integer between 0 and 100', options.maxSlope);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('options', 'plain object', options);\n  }\n  return this;\n}\n\n/**\n * Convolve the image with the specified kernel.\n *\n * @example\n * sharp(input)\n *   .convolve({\n *     width: 3,\n *     height: 3,\n *     kernel: [-1, 0, 1, -2, 0, 2, -1, 0, 1]\n *   })\n *   .raw()\n *   .toBuffer(function(err, data, info) {\n *     // data contains the raw pixel data representing the convolution\n *     // of the input image with the horizontal Sobel operator\n *   });\n *\n * @param {Object} kernel\n * @param {number} kernel.width - width of the kernel in pixels.\n * @param {number} kernel.height - height of the kernel in pixels.\n * @param {Array<number>} kernel.kernel - Array of length `width*height` containing the kernel values.\n * @param {number} [kernel.scale=sum] - the scale of the kernel in pixels.\n * @param {number} [kernel.offset=0] - the offset of the kernel in pixels.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction convolve(kernel) {\n  if (!is.object(kernel) || !Array.isArray(kernel.kernel) || !is.integer(kernel.width) || !is.integer(kernel.height) || !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) || kernel.height * kernel.width !== kernel.kernel.length) {\n    // must pass in a kernel\n    throw new Error('Invalid convolution kernel');\n  }\n  // Default scale is sum of kernel values\n  if (!is.integer(kernel.scale)) {\n    kernel.scale = kernel.kernel.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  }\n  // Clip scale to a minimum value of 1\n  if (kernel.scale < 1) {\n    kernel.scale = 1;\n  }\n  if (!is.integer(kernel.offset)) {\n    kernel.offset = 0;\n  }\n  this.options.convKernel = kernel;\n  return this;\n}\n\n/**\n * Any pixel value greater than or equal to the threshold value will be set to 255, otherwise it will be set to 0.\n * @param {number} [threshold=128] - a value in the range 0-255 representing the level at which the threshold will be applied.\n * @param {Object} [options]\n * @param {Boolean} [options.greyscale=true] - convert to single channel greyscale.\n * @param {Boolean} [options.grayscale=true] - alternative spelling for greyscale.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction threshold(threshold, options) {\n  if (!is.defined(threshold)) {\n    this.options.threshold = 128;\n  } else if (is.bool(threshold)) {\n    this.options.threshold = threshold ? 128 : 0;\n  } else if (is.integer(threshold) && is.inRange(threshold, 0, 255)) {\n    this.options.threshold = threshold;\n  } else {\n    throw is.invalidParameterError('threshold', 'integer between 0 and 255', threshold);\n  }\n  if (!is.object(options) || options.greyscale === true || options.grayscale === true) {\n    this.options.thresholdGrayscale = true;\n  } else {\n    this.options.thresholdGrayscale = false;\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation with operand image.\n *\n * This operation creates an output image where each pixel is the result of\n * the selected bitwise boolean `operation` between the corresponding pixels of the input images.\n *\n * @param {Buffer|string} operand - Buffer containing image data or string containing the path to an image file.\n * @param {string} operator - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @param {Object} [options]\n * @param {Object} [options.raw] - describes operand when using raw pixel data.\n * @param {number} [options.raw.width]\n * @param {number} [options.raw.height]\n * @param {number} [options.raw.channels]\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction boolean(operand, operator, options) {\n  this.options.boolean = this._createInputDescriptor(operand, options);\n  if (is.string(operator) && is.inArray(operator, ['and', 'or', 'eor'])) {\n    this.options.booleanOp = operator;\n  } else {\n    throw is.invalidParameterError('operator', 'one of: and, or, eor', operator);\n  }\n  return this;\n}\n\n/**\n * Apply the linear formula `a` * input + `b` to the image to adjust image levels.\n *\n * When a single number is provided, it will be used for all image channels.\n * When an array of numbers is provided, the array length must match the number of channels.\n *\n * @example\n * await sharp(input)\n *   .linear(0.5, 2)\n *   .toBuffer();\n *\n * @example\n * await sharp(rgbInput)\n *   .linear(\n *     [0.25, 0.5, 0.75],\n *     [150, 100, 50]\n *   )\n *   .toBuffer();\n *\n * @param {(number|number[])} [a=[]] multiplier\n * @param {(number|number[])} [b=[]] offset\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction linear(a, b) {\n  if (!is.defined(a) && is.number(b)) {\n    a = 1.0;\n  } else if (is.number(a) && !is.defined(b)) {\n    b = 0.0;\n  }\n  if (!is.defined(a)) {\n    this.options.linearA = [];\n  } else if (is.number(a)) {\n    this.options.linearA = [a];\n  } else if (Array.isArray(a) && a.length && a.every(is.number)) {\n    this.options.linearA = a;\n  } else {\n    throw is.invalidParameterError('a', 'number or array of numbers', a);\n  }\n  if (!is.defined(b)) {\n    this.options.linearB = [];\n  } else if (is.number(b)) {\n    this.options.linearB = [b];\n  } else if (Array.isArray(b) && b.length && b.every(is.number)) {\n    this.options.linearB = b;\n  } else {\n    throw is.invalidParameterError('b', 'number or array of numbers', b);\n  }\n  if (this.options.linearA.length !== this.options.linearB.length) {\n    throw new Error('Expected a and b to be arrays of the same length');\n  }\n  return this;\n}\n\n/**\n * Recomb the image with the specified matrix.\n *\n * @since 0.21.1\n *\n * @example\n * sharp(input)\n *   .recomb([\n *    [0.3588, 0.7044, 0.1368],\n *    [0.2990, 0.5870, 0.1140],\n *    [0.2392, 0.4696, 0.0912],\n *   ])\n *   .raw()\n *   .toBuffer(function(err, data, info) {\n *     // data contains the raw pixel data after applying the recomb\n *     // With this example input, a sepia filter has been applied\n *   });\n *\n * @param {Array<Array<number>>} inputMatrix - 3x3 Recombination matrix\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction recomb(inputMatrix) {\n  if (!Array.isArray(inputMatrix) || inputMatrix.length !== 3 || inputMatrix[0].length !== 3 || inputMatrix[1].length !== 3 || inputMatrix[2].length !== 3) {\n    // must pass in a kernel\n    throw new Error('Invalid recombination matrix');\n  }\n  this.options.recombMatrix = [inputMatrix[0][0], inputMatrix[0][1], inputMatrix[0][2], inputMatrix[1][0], inputMatrix[1][1], inputMatrix[1][2], inputMatrix[2][0], inputMatrix[2][1], inputMatrix[2][2]].map(Number);\n  return this;\n}\n\n/**\n * Transforms the image using brightness, saturation, hue rotation, and lightness.\n * Brightness and lightness both operate on luminance, with the difference being that\n * brightness is multiplicative whereas lightness is additive.\n *\n * @since 0.22.1\n *\n * @example\n * // increase brightness by a factor of 2\n * const output = await sharp(input)\n *   .modulate({\n *     brightness: 2\n *   })\n *   .toBuffer();\n *\n * @example\n * // hue-rotate by 180 degrees\n * const output = await sharp(input)\n *   .modulate({\n *     hue: 180\n *   })\n *   .toBuffer();\n *\n * @example\n * // increase lightness by +50\n * const output = await sharp(input)\n *   .modulate({\n *     lightness: 50\n *   })\n *   .toBuffer();\n *\n * @example\n * // decreate brightness and saturation while also hue-rotating by 90 degrees\n * const output = await sharp(input)\n *   .modulate({\n *     brightness: 0.5,\n *     saturation: 0.5,\n *     hue: 90,\n *   })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.brightness] Brightness multiplier\n * @param {number} [options.saturation] Saturation multiplier\n * @param {number} [options.hue] Degrees for hue rotation\n * @param {number} [options.lightness] Lightness addend\n * @returns {Sharp}\n */\nfunction modulate(options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'plain object', options);\n  }\n  if ('brightness' in options) {\n    if (is.number(options.brightness) && options.brightness >= 0) {\n      this.options.brightness = options.brightness;\n    } else {\n      throw is.invalidParameterError('brightness', 'number above zero', options.brightness);\n    }\n  }\n  if ('saturation' in options) {\n    if (is.number(options.saturation) && options.saturation >= 0) {\n      this.options.saturation = options.saturation;\n    } else {\n      throw is.invalidParameterError('saturation', 'number above zero', options.saturation);\n    }\n  }\n  if ('hue' in options) {\n    if (is.integer(options.hue)) {\n      this.options.hue = options.hue % 360;\n    } else {\n      throw is.invalidParameterError('hue', 'number', options.hue);\n    }\n  }\n  if ('lightness' in options) {\n    if (is.number(options.lightness)) {\n      this.options.lightness = options.lightness;\n    } else {\n      throw is.invalidParameterError('lightness', 'number', options.lightness);\n    }\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with operation-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    rotate,\n    flip,\n    flop,\n    affine,\n    sharpen,\n    median,\n    blur,\n    flatten,\n    unflatten,\n    gamma,\n    negate,\n    normalise,\n    normalize,\n    clahe,\n    convolve,\n    threshold,\n    boolean,\n    linear,\n    recomb,\n    modulate\n  });\n};","map":{"version":3,"names":["color","require","is","rotate","angle","options","useExifOrientation","rotationAngle","debuglog","defined","integer","number","object","background","backgroundColour","rotationBackground","red","green","blue","Math","round","alpha","invalidParameterError","flip","bool","flop","affine","matrix","flatMatrix","concat","length","every","affineMatrix","_setBackgroundColourOption","idx","affineIdx","idy","affineIdy","odx","affineOdx","ody","affineOdy","interpolator","inArray","Object","values","constructor","interpolators","affineInterpolator","sharpen","flat","jagged","sharpenSigma","inRange","sharpenM1","sharpenM2","plainObject","sigma","m1","m2","x1","sharpenX1","y2","sharpenY2","y3","sharpenY3","median","size","medianSize","blur","blurSigma","flatten","unflatten","gamma","gammaOut","negate","negateAlpha","normalise","lower","normaliseLower","upper","normaliseUpper","normalize","clahe","width","claheWidth","height","claheHeight","maxSlope","claheMaxSlope","convolve","kernel","Array","isArray","Error","scale","reduce","a","b","offset","convKernel","threshold","greyscale","grayscale","thresholdGrayscale","boolean","operand","operator","_createInputDescriptor","string","booleanOp","linear","linearA","linearB","recomb","inputMatrix","recombMatrix","map","Number","modulate","brightness","saturation","hue","lightness","module","exports","Sharp","assign","prototype"],"sources":["/Users/divyakulkarni/Desktop/IAMW/image-annotation-measurement/node_modules/sharp/lib/operation.js"],"sourcesContent":["// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst color = require('color');\nconst is = require('./is');\n\n/**\n * Rotate the output image by either an explicit angle\n * or auto-orient based on the EXIF `Orientation` tag.\n *\n * If an angle is provided, it is converted to a valid positive degree rotation.\n * For example, `-450` will produce a 270deg rotation.\n *\n * When rotating by an angle other than a multiple of 90,\n * the background colour can be provided with the `background` option.\n *\n * If no angle is provided, it is determined from the EXIF data.\n * Mirroring is supported and may infer the use of a flip operation.\n *\n * The use of `rotate` implies the removal of the EXIF `Orientation` tag, if any.\n *\n * Only one rotation can occur per pipeline.\n * Previous calls to `rotate` in the same pipeline will be ignored.\n *\n * Method order is important when rotating, resizing and/or extracting regions,\n * for example `.rotate(x).extract(y)` will produce a different result to `.extract(y).rotate(x)`.\n *\n * @example\n * const pipeline = sharp()\n *   .rotate()\n *   .resize(null, 200)\n *   .toBuffer(function (err, outputBuffer, info) {\n *     // outputBuffer contains 200px high JPEG image data,\n *     // auto-rotated using EXIF Orientation tag\n *     // info.width and info.height contain the dimensions of the resized image\n *   });\n * readableStream.pipe(pipeline);\n *\n * @example\n * const rotateThenResize = await sharp(input)\n *   .rotate(90)\n *   .resize({ width: 16, height: 8, fit: 'fill' })\n *   .toBuffer();\n * const resizeThenRotate = await sharp(input)\n *   .resize({ width: 16, height: 8, fit: 'fill' })\n *   .rotate(90)\n *   .toBuffer();\n *\n * @param {number} [angle=auto] angle of rotation.\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {string|Object} [options.background=\"#000000\"] parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction rotate (angle, options) {\n  if (this.options.useExifOrientation || this.options.angle || this.options.rotationAngle) {\n    this.options.debuglog('ignoring previous rotate options');\n  }\n  if (!is.defined(angle)) {\n    this.options.useExifOrientation = true;\n  } else if (is.integer(angle) && !(angle % 90)) {\n    this.options.angle = angle;\n  } else if (is.number(angle)) {\n    this.options.rotationAngle = angle;\n    if (is.object(options) && options.background) {\n      const backgroundColour = color(options.background);\n      this.options.rotationBackground = [\n        backgroundColour.red(),\n        backgroundColour.green(),\n        backgroundColour.blue(),\n        Math.round(backgroundColour.alpha() * 255)\n      ];\n    }\n  } else {\n    throw is.invalidParameterError('angle', 'numeric', angle);\n  }\n  return this;\n}\n\n/**\n * Flip the image about the vertical Y axis. This always occurs before rotation, if any.\n * The use of `flip` implies the removal of the EXIF `Orientation` tag, if any.\n *\n * @example\n * const output = await sharp(input).flip().toBuffer();\n *\n * @param {Boolean} [flip=true]\n * @returns {Sharp}\n */\nfunction flip (flip) {\n  this.options.flip = is.bool(flip) ? flip : true;\n  return this;\n}\n\n/**\n * Flop the image about the horizontal X axis. This always occurs before rotation, if any.\n * The use of `flop` implies the removal of the EXIF `Orientation` tag, if any.\n *\n * @example\n * const output = await sharp(input).flop().toBuffer();\n *\n * @param {Boolean} [flop=true]\n * @returns {Sharp}\n */\nfunction flop (flop) {\n  this.options.flop = is.bool(flop) ? flop : true;\n  return this;\n}\n\n/**\n * Perform an affine transform on an image. This operation will always occur after resizing, extraction and rotation, if any.\n *\n * You must provide an array of length 4 or a 2x2 affine transformation matrix.\n * By default, new pixels are filled with a black background. You can provide a background color with the `background` option.\n * A particular interpolator may also be specified. Set the `interpolator` option to an attribute of the `sharp.interpolators` Object e.g. `sharp.interpolators.nohalo`.\n *\n * In the case of a 2x2 matrix, the transform is:\n * - X = `matrix[0, 0]` \\* (x + `idx`) + `matrix[0, 1]` \\* (y + `idy`) + `odx`\n * - Y = `matrix[1, 0]` \\* (x + `idx`) + `matrix[1, 1]` \\* (y + `idy`) + `ody`\n *\n * where:\n * - x and y are the coordinates in input image.\n * - X and Y are the coordinates in output image.\n * - (0,0) is the upper left corner.\n *\n * @since 0.27.0\n *\n * @example\n * const pipeline = sharp()\n *   .affine([[1, 0.3], [0.1, 0.7]], {\n *      background: 'white',\n *      interpolator: sharp.interpolators.nohalo\n *   })\n *   .toBuffer((err, outputBuffer, info) => {\n *      // outputBuffer contains the transformed image\n *      // info.width and info.height contain the new dimensions\n *   });\n *\n * inputStream\n *   .pipe(pipeline);\n *\n * @param {Array<Array<number>>|Array<number>} matrix - affine transformation matrix\n * @param {Object} [options] - if present, is an Object with optional attributes.\n * @param {String|Object} [options.background=\"#000000\"] - parsed by the [color](https://www.npmjs.org/package/color) module to extract values for red, green, blue and alpha.\n * @param {Number} [options.idx=0] - input horizontal offset\n * @param {Number} [options.idy=0] - input vertical offset\n * @param {Number} [options.odx=0] - output horizontal offset\n * @param {Number} [options.ody=0] - output vertical offset\n * @param {String} [options.interpolator=sharp.interpolators.bicubic] - interpolator\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction affine (matrix, options) {\n  const flatMatrix = [].concat(...matrix);\n  if (flatMatrix.length === 4 && flatMatrix.every(is.number)) {\n    this.options.affineMatrix = flatMatrix;\n  } else {\n    throw is.invalidParameterError('matrix', '1x4 or 2x2 array', matrix);\n  }\n\n  if (is.defined(options)) {\n    if (is.object(options)) {\n      this._setBackgroundColourOption('affineBackground', options.background);\n      if (is.defined(options.idx)) {\n        if (is.number(options.idx)) {\n          this.options.affineIdx = options.idx;\n        } else {\n          throw is.invalidParameterError('options.idx', 'number', options.idx);\n        }\n      }\n      if (is.defined(options.idy)) {\n        if (is.number(options.idy)) {\n          this.options.affineIdy = options.idy;\n        } else {\n          throw is.invalidParameterError('options.idy', 'number', options.idy);\n        }\n      }\n      if (is.defined(options.odx)) {\n        if (is.number(options.odx)) {\n          this.options.affineOdx = options.odx;\n        } else {\n          throw is.invalidParameterError('options.odx', 'number', options.odx);\n        }\n      }\n      if (is.defined(options.ody)) {\n        if (is.number(options.ody)) {\n          this.options.affineOdy = options.ody;\n        } else {\n          throw is.invalidParameterError('options.ody', 'number', options.ody);\n        }\n      }\n      if (is.defined(options.interpolator)) {\n        if (is.inArray(options.interpolator, Object.values(this.constructor.interpolators))) {\n          this.options.affineInterpolator = options.interpolator;\n        } else {\n          throw is.invalidParameterError('options.interpolator', 'valid interpolator name', options.interpolator);\n        }\n      }\n    } else {\n      throw is.invalidParameterError('options', 'object', options);\n    }\n  }\n\n  return this;\n}\n\n/**\n * Sharpen the image.\n *\n * When used without parameters, performs a fast, mild sharpen of the output image.\n *\n * When a `sigma` is provided, performs a slower, more accurate sharpen of the L channel in the LAB colour space.\n * Fine-grained control over the level of sharpening in \"flat\" (m1) and \"jagged\" (m2) areas is available.\n *\n * See {@link https://www.libvips.org/API/current/libvips-convolution.html#vips-sharpen|libvips sharpen} operation.\n *\n * @example\n * const data = await sharp(input).sharpen().toBuffer();\n *\n * @example\n * const data = await sharp(input).sharpen({ sigma: 2 }).toBuffer();\n *\n * @example\n * const data = await sharp(input)\n *   .sharpen({\n *     sigma: 2,\n *     m1: 0,\n *     m2: 3,\n *     x1: 3,\n *     y2: 15,\n *     y3: 15,\n *   })\n *   .toBuffer();\n *\n * @param {Object|number} [options] - if present, is an Object with attributes\n * @param {number} [options.sigma] - the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`, between 0.000001 and 10\n * @param {number} [options.m1=1.0] - the level of sharpening to apply to \"flat\" areas, between 0 and 1000000\n * @param {number} [options.m2=2.0] - the level of sharpening to apply to \"jagged\" areas, between 0 and 1000000\n * @param {number} [options.x1=2.0] - threshold between \"flat\" and \"jagged\", between 0 and 1000000\n * @param {number} [options.y2=10.0] - maximum amount of brightening, between 0 and 1000000\n * @param {number} [options.y3=20.0] - maximum amount of darkening, between 0 and 1000000\n * @param {number} [flat] - (deprecated) see `options.m1`.\n * @param {number} [jagged] - (deprecated) see `options.m2`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction sharpen (options, flat, jagged) {\n  if (!is.defined(options)) {\n    // No arguments: default to mild sharpen\n    this.options.sharpenSigma = -1;\n  } else if (is.bool(options)) {\n    // Deprecated boolean argument: apply mild sharpen?\n    this.options.sharpenSigma = options ? -1 : 0;\n  } else if (is.number(options) && is.inRange(options, 0.01, 10000)) {\n    // Deprecated numeric argument: specific sigma\n    this.options.sharpenSigma = options;\n    // Deprecated control over flat areas\n    if (is.defined(flat)) {\n      if (is.number(flat) && is.inRange(flat, 0, 10000)) {\n        this.options.sharpenM1 = flat;\n      } else {\n        throw is.invalidParameterError('flat', 'number between 0 and 10000', flat);\n      }\n    }\n    // Deprecated control over jagged areas\n    if (is.defined(jagged)) {\n      if (is.number(jagged) && is.inRange(jagged, 0, 10000)) {\n        this.options.sharpenM2 = jagged;\n      } else {\n        throw is.invalidParameterError('jagged', 'number between 0 and 10000', jagged);\n      }\n    }\n  } else if (is.plainObject(options)) {\n    if (is.number(options.sigma) && is.inRange(options.sigma, 0.000001, 10)) {\n      this.options.sharpenSigma = options.sigma;\n    } else {\n      throw is.invalidParameterError('options.sigma', 'number between 0.000001 and 10', options.sigma);\n    }\n    if (is.defined(options.m1)) {\n      if (is.number(options.m1) && is.inRange(options.m1, 0, 1000000)) {\n        this.options.sharpenM1 = options.m1;\n      } else {\n        throw is.invalidParameterError('options.m1', 'number between 0 and 1000000', options.m1);\n      }\n    }\n    if (is.defined(options.m2)) {\n      if (is.number(options.m2) && is.inRange(options.m2, 0, 1000000)) {\n        this.options.sharpenM2 = options.m2;\n      } else {\n        throw is.invalidParameterError('options.m2', 'number between 0 and 1000000', options.m2);\n      }\n    }\n    if (is.defined(options.x1)) {\n      if (is.number(options.x1) && is.inRange(options.x1, 0, 1000000)) {\n        this.options.sharpenX1 = options.x1;\n      } else {\n        throw is.invalidParameterError('options.x1', 'number between 0 and 1000000', options.x1);\n      }\n    }\n    if (is.defined(options.y2)) {\n      if (is.number(options.y2) && is.inRange(options.y2, 0, 1000000)) {\n        this.options.sharpenY2 = options.y2;\n      } else {\n        throw is.invalidParameterError('options.y2', 'number between 0 and 1000000', options.y2);\n      }\n    }\n    if (is.defined(options.y3)) {\n      if (is.number(options.y3) && is.inRange(options.y3, 0, 1000000)) {\n        this.options.sharpenY3 = options.y3;\n      } else {\n        throw is.invalidParameterError('options.y3', 'number between 0 and 1000000', options.y3);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('sigma', 'number between 0.01 and 10000', options);\n  }\n  return this;\n}\n\n/**\n * Apply median filter.\n * When used without parameters the default window is 3x3.\n *\n * @example\n * const output = await sharp(input).median().toBuffer();\n *\n * @example\n * const output = await sharp(input).median(5).toBuffer();\n *\n * @param {number} [size=3] square mask size: size x size\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction median (size) {\n  if (!is.defined(size)) {\n    // No arguments: default to 3x3\n    this.options.medianSize = 3;\n  } else if (is.integer(size) && is.inRange(size, 1, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.medianSize = size;\n  } else {\n    throw is.invalidParameterError('size', 'integer between 1 and 1000', size);\n  }\n  return this;\n}\n\n/**\n * Blur the image.\n *\n * When used without parameters, performs a fast 3x3 box blur (equivalent to a box linear filter).\n *\n * When a `sigma` is provided, performs a slower, more accurate Gaussian blur.\n *\n * @example\n * const boxBlurred = await sharp(input)\n *   .blur()\n *   .toBuffer();\n *\n * @example\n * const gaussianBlurred = await sharp(input)\n *   .blur(5)\n *   .toBuffer();\n *\n * @param {number} [sigma] a value between 0.3 and 1000 representing the sigma of the Gaussian mask, where `sigma = 1 + radius / 2`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction blur (sigma) {\n  if (!is.defined(sigma)) {\n    // No arguments: default to mild blur\n    this.options.blurSigma = -1;\n  } else if (is.bool(sigma)) {\n    // Boolean argument: apply mild blur?\n    this.options.blurSigma = sigma ? -1 : 0;\n  } else if (is.number(sigma) && is.inRange(sigma, 0.3, 1000)) {\n    // Numeric argument: specific sigma\n    this.options.blurSigma = sigma;\n  } else {\n    throw is.invalidParameterError('sigma', 'number between 0.3 and 1000', sigma);\n  }\n  return this;\n}\n\n/**\n * Merge alpha transparency channel, if any, with a background, then remove the alpha channel.\n *\n * See also {@link /api-channel#removealpha|removeAlpha}.\n *\n * @example\n * await sharp(rgbaInput)\n *   .flatten({ background: '#F0A703' })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {string|Object} [options.background={r: 0, g: 0, b: 0}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black.\n * @returns {Sharp}\n */\nfunction flatten (options) {\n  this.options.flatten = is.bool(options) ? options : true;\n  if (is.object(options)) {\n    this._setBackgroundColourOption('flattenBackground', options.background);\n  }\n  return this;\n}\n\n/**\n * Ensure the image has an alpha channel\n * with all white pixel values made fully transparent.\n *\n * Existing alpha channel values for non-white pixels remain unchanged.\n *\n * This feature is experimental and the API may change.\n *\n * @since 0.32.1\n *\n * @example\n * await sharp(rgbInput)\n *   .unflatten()\n *   .toBuffer();\n *\n * @example\n * await sharp(rgbInput)\n *   .threshold(128, { grayscale: false }) // converter bright pixels to white\n *   .unflatten()\n *   .toBuffer();\n */\nfunction unflatten () {\n  this.options.unflatten = true;\n  return this;\n}\n\n/**\n * Apply a gamma correction by reducing the encoding (darken) pre-resize at a factor of `1/gamma`\n * then increasing the encoding (brighten) post-resize at a factor of `gamma`.\n * This can improve the perceived brightness of a resized image in non-linear colour spaces.\n * JPEG and WebP input images will not take advantage of the shrink-on-load performance optimisation\n * when applying a gamma correction.\n *\n * Supply a second argument to use a different output gamma value, otherwise the first value is used in both cases.\n *\n * @param {number} [gamma=2.2] value between 1.0 and 3.0.\n * @param {number} [gammaOut] value between 1.0 and 3.0. (optional, defaults to same as `gamma`)\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction gamma (gamma, gammaOut) {\n  if (!is.defined(gamma)) {\n    // Default gamma correction of 2.2 (sRGB)\n    this.options.gamma = 2.2;\n  } else if (is.number(gamma) && is.inRange(gamma, 1, 3)) {\n    this.options.gamma = gamma;\n  } else {\n    throw is.invalidParameterError('gamma', 'number between 1.0 and 3.0', gamma);\n  }\n  if (!is.defined(gammaOut)) {\n    // Default gamma correction for output is same as input\n    this.options.gammaOut = this.options.gamma;\n  } else if (is.number(gammaOut) && is.inRange(gammaOut, 1, 3)) {\n    this.options.gammaOut = gammaOut;\n  } else {\n    throw is.invalidParameterError('gammaOut', 'number between 1.0 and 3.0', gammaOut);\n  }\n  return this;\n}\n\n/**\n * Produce the \"negative\" of the image.\n *\n * @example\n * const output = await sharp(input)\n *   .negate()\n *   .toBuffer();\n *\n * @example\n * const output = await sharp(input)\n *   .negate({ alpha: false })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {Boolean} [options.alpha=true] Whether or not to negate any alpha channel\n * @returns {Sharp}\n */\nfunction negate (options) {\n  this.options.negate = is.bool(options) ? options : true;\n  if (is.plainObject(options) && 'alpha' in options) {\n    if (!is.bool(options.alpha)) {\n      throw is.invalidParameterError('alpha', 'should be boolean value', options.alpha);\n    } else {\n      this.options.negateAlpha = options.alpha;\n    }\n  }\n  return this;\n}\n\n/**\n * Enhance output image contrast by stretching its luminance to cover a full dynamic range.\n *\n * Uses a histogram-based approach, taking a default range of 1% to 99% to reduce sensitivity to noise at the extremes.\n *\n * Luminance values below the `lower` percentile will be underexposed by clipping to zero.\n * Luminance values above the `upper` percentile will be overexposed by clipping to the max pixel value.\n *\n * @example\n * const output = await sharp(input)\n *   .normalise()\n *   .toBuffer();\n *\n * @example\n * const output = await sharp(input)\n *   .normalise({ lower: 0, upper: 100 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.lower=1] - Percentile below which luminance values will be underexposed.\n * @param {number} [options.upper=99] - Percentile above which luminance values will be overexposed.\n * @returns {Sharp}\n */\nfunction normalise (options) {\n  if (is.plainObject(options)) {\n    if (is.defined(options.lower)) {\n      if (is.number(options.lower) && is.inRange(options.lower, 0, 99)) {\n        this.options.normaliseLower = options.lower;\n      } else {\n        throw is.invalidParameterError('lower', 'number between 0 and 99', options.lower);\n      }\n    }\n    if (is.defined(options.upper)) {\n      if (is.number(options.upper) && is.inRange(options.upper, 1, 100)) {\n        this.options.normaliseUpper = options.upper;\n      } else {\n        throw is.invalidParameterError('upper', 'number between 1 and 100', options.upper);\n      }\n    }\n  }\n  if (this.options.normaliseLower >= this.options.normaliseUpper) {\n    throw is.invalidParameterError('range', 'lower to be less than upper',\n      `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`);\n  }\n  this.options.normalise = true;\n  return this;\n}\n\n/**\n * Alternative spelling of normalise.\n *\n * @example\n * const output = await sharp(input)\n *   .normalize()\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.lower=1] - Percentile below which luminance values will be underexposed.\n * @param {number} [options.upper=99] - Percentile above which luminance values will be overexposed.\n * @returns {Sharp}\n */\nfunction normalize (options) {\n  return this.normalise(options);\n}\n\n/**\n * Perform contrast limiting adaptive histogram equalization\n * {@link https://en.wikipedia.org/wiki/Adaptive_histogram_equalization#Contrast_Limited_AHE|CLAHE}.\n *\n * This will, in general, enhance the clarity of the image by bringing out darker details.\n *\n * @since 0.28.3\n *\n * @example\n * const output = await sharp(input)\n *   .clahe({\n *     width: 3,\n *     height: 3,\n *   })\n *   .toBuffer();\n *\n * @param {Object} options\n * @param {number} options.width - Integral width of the search window, in pixels.\n * @param {number} options.height - Integral height of the search window, in pixels.\n * @param {number} [options.maxSlope=3] - Integral level of brightening, between 0 and 100, where 0 disables contrast limiting.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction clahe (options) {\n  if (is.plainObject(options)) {\n    if (is.integer(options.width) && options.width > 0) {\n      this.options.claheWidth = options.width;\n    } else {\n      throw is.invalidParameterError('width', 'integer greater than zero', options.width);\n    }\n    if (is.integer(options.height) && options.height > 0) {\n      this.options.claheHeight = options.height;\n    } else {\n      throw is.invalidParameterError('height', 'integer greater than zero', options.height);\n    }\n    if (is.defined(options.maxSlope)) {\n      if (is.integer(options.maxSlope) && is.inRange(options.maxSlope, 0, 100)) {\n        this.options.claheMaxSlope = options.maxSlope;\n      } else {\n        throw is.invalidParameterError('maxSlope', 'integer between 0 and 100', options.maxSlope);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('options', 'plain object', options);\n  }\n  return this;\n}\n\n/**\n * Convolve the image with the specified kernel.\n *\n * @example\n * sharp(input)\n *   .convolve({\n *     width: 3,\n *     height: 3,\n *     kernel: [-1, 0, 1, -2, 0, 2, -1, 0, 1]\n *   })\n *   .raw()\n *   .toBuffer(function(err, data, info) {\n *     // data contains the raw pixel data representing the convolution\n *     // of the input image with the horizontal Sobel operator\n *   });\n *\n * @param {Object} kernel\n * @param {number} kernel.width - width of the kernel in pixels.\n * @param {number} kernel.height - height of the kernel in pixels.\n * @param {Array<number>} kernel.kernel - Array of length `width*height` containing the kernel values.\n * @param {number} [kernel.scale=sum] - the scale of the kernel in pixels.\n * @param {number} [kernel.offset=0] - the offset of the kernel in pixels.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction convolve (kernel) {\n  if (!is.object(kernel) || !Array.isArray(kernel.kernel) ||\n      !is.integer(kernel.width) || !is.integer(kernel.height) ||\n      !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) ||\n      kernel.height * kernel.width !== kernel.kernel.length\n  ) {\n    // must pass in a kernel\n    throw new Error('Invalid convolution kernel');\n  }\n  // Default scale is sum of kernel values\n  if (!is.integer(kernel.scale)) {\n    kernel.scale = kernel.kernel.reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  }\n  // Clip scale to a minimum value of 1\n  if (kernel.scale < 1) {\n    kernel.scale = 1;\n  }\n  if (!is.integer(kernel.offset)) {\n    kernel.offset = 0;\n  }\n  this.options.convKernel = kernel;\n  return this;\n}\n\n/**\n * Any pixel value greater than or equal to the threshold value will be set to 255, otherwise it will be set to 0.\n * @param {number} [threshold=128] - a value in the range 0-255 representing the level at which the threshold will be applied.\n * @param {Object} [options]\n * @param {Boolean} [options.greyscale=true] - convert to single channel greyscale.\n * @param {Boolean} [options.grayscale=true] - alternative spelling for greyscale.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction threshold (threshold, options) {\n  if (!is.defined(threshold)) {\n    this.options.threshold = 128;\n  } else if (is.bool(threshold)) {\n    this.options.threshold = threshold ? 128 : 0;\n  } else if (is.integer(threshold) && is.inRange(threshold, 0, 255)) {\n    this.options.threshold = threshold;\n  } else {\n    throw is.invalidParameterError('threshold', 'integer between 0 and 255', threshold);\n  }\n  if (!is.object(options) || options.greyscale === true || options.grayscale === true) {\n    this.options.thresholdGrayscale = true;\n  } else {\n    this.options.thresholdGrayscale = false;\n  }\n  return this;\n}\n\n/**\n * Perform a bitwise boolean operation with operand image.\n *\n * This operation creates an output image where each pixel is the result of\n * the selected bitwise boolean `operation` between the corresponding pixels of the input images.\n *\n * @param {Buffer|string} operand - Buffer containing image data or string containing the path to an image file.\n * @param {string} operator - one of `and`, `or` or `eor` to perform that bitwise operation, like the C logic operators `&`, `|` and `^` respectively.\n * @param {Object} [options]\n * @param {Object} [options.raw] - describes operand when using raw pixel data.\n * @param {number} [options.raw.width]\n * @param {number} [options.raw.height]\n * @param {number} [options.raw.channels]\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction boolean (operand, operator, options) {\n  this.options.boolean = this._createInputDescriptor(operand, options);\n  if (is.string(operator) && is.inArray(operator, ['and', 'or', 'eor'])) {\n    this.options.booleanOp = operator;\n  } else {\n    throw is.invalidParameterError('operator', 'one of: and, or, eor', operator);\n  }\n  return this;\n}\n\n/**\n * Apply the linear formula `a` * input + `b` to the image to adjust image levels.\n *\n * When a single number is provided, it will be used for all image channels.\n * When an array of numbers is provided, the array length must match the number of channels.\n *\n * @example\n * await sharp(input)\n *   .linear(0.5, 2)\n *   .toBuffer();\n *\n * @example\n * await sharp(rgbInput)\n *   .linear(\n *     [0.25, 0.5, 0.75],\n *     [150, 100, 50]\n *   )\n *   .toBuffer();\n *\n * @param {(number|number[])} [a=[]] multiplier\n * @param {(number|number[])} [b=[]] offset\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction linear (a, b) {\n  if (!is.defined(a) && is.number(b)) {\n    a = 1.0;\n  } else if (is.number(a) && !is.defined(b)) {\n    b = 0.0;\n  }\n  if (!is.defined(a)) {\n    this.options.linearA = [];\n  } else if (is.number(a)) {\n    this.options.linearA = [a];\n  } else if (Array.isArray(a) && a.length && a.every(is.number)) {\n    this.options.linearA = a;\n  } else {\n    throw is.invalidParameterError('a', 'number or array of numbers', a);\n  }\n  if (!is.defined(b)) {\n    this.options.linearB = [];\n  } else if (is.number(b)) {\n    this.options.linearB = [b];\n  } else if (Array.isArray(b) && b.length && b.every(is.number)) {\n    this.options.linearB = b;\n  } else {\n    throw is.invalidParameterError('b', 'number or array of numbers', b);\n  }\n  if (this.options.linearA.length !== this.options.linearB.length) {\n    throw new Error('Expected a and b to be arrays of the same length');\n  }\n  return this;\n}\n\n/**\n * Recomb the image with the specified matrix.\n *\n * @since 0.21.1\n *\n * @example\n * sharp(input)\n *   .recomb([\n *    [0.3588, 0.7044, 0.1368],\n *    [0.2990, 0.5870, 0.1140],\n *    [0.2392, 0.4696, 0.0912],\n *   ])\n *   .raw()\n *   .toBuffer(function(err, data, info) {\n *     // data contains the raw pixel data after applying the recomb\n *     // With this example input, a sepia filter has been applied\n *   });\n *\n * @param {Array<Array<number>>} inputMatrix - 3x3 Recombination matrix\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction recomb (inputMatrix) {\n  if (!Array.isArray(inputMatrix) || inputMatrix.length !== 3 ||\n      inputMatrix[0].length !== 3 ||\n      inputMatrix[1].length !== 3 ||\n      inputMatrix[2].length !== 3\n  ) {\n    // must pass in a kernel\n    throw new Error('Invalid recombination matrix');\n  }\n  this.options.recombMatrix = [\n    inputMatrix[0][0], inputMatrix[0][1], inputMatrix[0][2],\n    inputMatrix[1][0], inputMatrix[1][1], inputMatrix[1][2],\n    inputMatrix[2][0], inputMatrix[2][1], inputMatrix[2][2]\n  ].map(Number);\n  return this;\n}\n\n/**\n * Transforms the image using brightness, saturation, hue rotation, and lightness.\n * Brightness and lightness both operate on luminance, with the difference being that\n * brightness is multiplicative whereas lightness is additive.\n *\n * @since 0.22.1\n *\n * @example\n * // increase brightness by a factor of 2\n * const output = await sharp(input)\n *   .modulate({\n *     brightness: 2\n *   })\n *   .toBuffer();\n *\n * @example\n * // hue-rotate by 180 degrees\n * const output = await sharp(input)\n *   .modulate({\n *     hue: 180\n *   })\n *   .toBuffer();\n *\n * @example\n * // increase lightness by +50\n * const output = await sharp(input)\n *   .modulate({\n *     lightness: 50\n *   })\n *   .toBuffer();\n *\n * @example\n * // decreate brightness and saturation while also hue-rotating by 90 degrees\n * const output = await sharp(input)\n *   .modulate({\n *     brightness: 0.5,\n *     saturation: 0.5,\n *     hue: 90,\n *   })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.brightness] Brightness multiplier\n * @param {number} [options.saturation] Saturation multiplier\n * @param {number} [options.hue] Degrees for hue rotation\n * @param {number} [options.lightness] Lightness addend\n * @returns {Sharp}\n */\nfunction modulate (options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'plain object', options);\n  }\n  if ('brightness' in options) {\n    if (is.number(options.brightness) && options.brightness >= 0) {\n      this.options.brightness = options.brightness;\n    } else {\n      throw is.invalidParameterError('brightness', 'number above zero', options.brightness);\n    }\n  }\n  if ('saturation' in options) {\n    if (is.number(options.saturation) && options.saturation >= 0) {\n      this.options.saturation = options.saturation;\n    } else {\n      throw is.invalidParameterError('saturation', 'number above zero', options.saturation);\n    }\n  }\n  if ('hue' in options) {\n    if (is.integer(options.hue)) {\n      this.options.hue = options.hue % 360;\n    } else {\n      throw is.invalidParameterError('hue', 'number', options.hue);\n    }\n  }\n  if ('lightness' in options) {\n    if (is.number(options.lightness)) {\n      this.options.lightness = options.lightness;\n    } else {\n      throw is.invalidParameterError('lightness', 'number', options.lightness);\n    }\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with operation-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    rotate,\n    flip,\n    flop,\n    affine,\n    sharpen,\n    median,\n    blur,\n    flatten,\n    unflatten,\n    gamma,\n    negate,\n    normalise,\n    normalize,\n    clahe,\n    convolve,\n    threshold,\n    boolean,\n    linear,\n    recomb,\n    modulate\n  });\n};\n"],"mappings":"AAAA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC9B,MAAMC,EAAE,GAAGD,OAAO,CAAC,MAAM,CAAC;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,MAAMA,CAAEC,KAAK,EAAEC,OAAO,EAAE;EAC/B,IAAI,IAAI,CAACA,OAAO,CAACC,kBAAkB,IAAI,IAAI,CAACD,OAAO,CAACD,KAAK,IAAI,IAAI,CAACC,OAAO,CAACE,aAAa,EAAE;IACvF,IAAI,CAACF,OAAO,CAACG,QAAQ,CAAC,kCAAkC,CAAC;EAC3D;EACA,IAAI,CAACN,EAAE,CAACO,OAAO,CAACL,KAAK,CAAC,EAAE;IACtB,IAAI,CAACC,OAAO,CAACC,kBAAkB,GAAG,IAAI;EACxC,CAAC,MAAM,IAAIJ,EAAE,CAACQ,OAAO,CAACN,KAAK,CAAC,IAAI,EAAEA,KAAK,GAAG,EAAE,CAAC,EAAE;IAC7C,IAAI,CAACC,OAAO,CAACD,KAAK,GAAGA,KAAK;EAC5B,CAAC,MAAM,IAAIF,EAAE,CAACS,MAAM,CAACP,KAAK,CAAC,EAAE;IAC3B,IAAI,CAACC,OAAO,CAACE,aAAa,GAAGH,KAAK;IAClC,IAAIF,EAAE,CAACU,MAAM,CAACP,OAAO,CAAC,IAAIA,OAAO,CAACQ,UAAU,EAAE;MAC5C,MAAMC,gBAAgB,GAAGd,KAAK,CAACK,OAAO,CAACQ,UAAU,CAAC;MAClD,IAAI,CAACR,OAAO,CAACU,kBAAkB,GAAG,CAChCD,gBAAgB,CAACE,GAAG,CAAC,CAAC,EACtBF,gBAAgB,CAACG,KAAK,CAAC,CAAC,EACxBH,gBAAgB,CAACI,IAAI,CAAC,CAAC,EACvBC,IAAI,CAACC,KAAK,CAACN,gBAAgB,CAACO,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC,CAC3C;IACH;EACF,CAAC,MAAM;IACL,MAAMnB,EAAE,CAACoB,qBAAqB,CAAC,OAAO,EAAE,SAAS,EAAElB,KAAK,CAAC;EAC3D;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmB,IAAIA,CAAEA,IAAI,EAAE;EACnB,IAAI,CAAClB,OAAO,CAACkB,IAAI,GAAGrB,EAAE,CAACsB,IAAI,CAACD,IAAI,CAAC,GAAGA,IAAI,GAAG,IAAI;EAC/C,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,IAAIA,CAAEA,IAAI,EAAE;EACnB,IAAI,CAACpB,OAAO,CAACoB,IAAI,GAAGvB,EAAE,CAACsB,IAAI,CAACC,IAAI,CAAC,GAAGA,IAAI,GAAG,IAAI;EAC/C,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAAEC,MAAM,EAAEtB,OAAO,EAAE;EAChC,MAAMuB,UAAU,GAAG,EAAE,CAACC,MAAM,CAAC,GAAGF,MAAM,CAAC;EACvC,IAAIC,UAAU,CAACE,MAAM,KAAK,CAAC,IAAIF,UAAU,CAACG,KAAK,CAAC7B,EAAE,CAACS,MAAM,CAAC,EAAE;IAC1D,IAAI,CAACN,OAAO,CAAC2B,YAAY,GAAGJ,UAAU;EACxC,CAAC,MAAM;IACL,MAAM1B,EAAE,CAACoB,qBAAqB,CAAC,QAAQ,EAAE,kBAAkB,EAAEK,MAAM,CAAC;EACtE;EAEA,IAAIzB,EAAE,CAACO,OAAO,CAACJ,OAAO,CAAC,EAAE;IACvB,IAAIH,EAAE,CAACU,MAAM,CAACP,OAAO,CAAC,EAAE;MACtB,IAAI,CAAC4B,0BAA0B,CAAC,kBAAkB,EAAE5B,OAAO,CAACQ,UAAU,CAAC;MACvE,IAAIX,EAAE,CAACO,OAAO,CAACJ,OAAO,CAAC6B,GAAG,CAAC,EAAE;QAC3B,IAAIhC,EAAE,CAACS,MAAM,CAACN,OAAO,CAAC6B,GAAG,CAAC,EAAE;UAC1B,IAAI,CAAC7B,OAAO,CAAC8B,SAAS,GAAG9B,OAAO,CAAC6B,GAAG;QACtC,CAAC,MAAM;UACL,MAAMhC,EAAE,CAACoB,qBAAqB,CAAC,aAAa,EAAE,QAAQ,EAAEjB,OAAO,CAAC6B,GAAG,CAAC;QACtE;MACF;MACA,IAAIhC,EAAE,CAACO,OAAO,CAACJ,OAAO,CAAC+B,GAAG,CAAC,EAAE;QAC3B,IAAIlC,EAAE,CAACS,MAAM,CAACN,OAAO,CAAC+B,GAAG,CAAC,EAAE;UAC1B,IAAI,CAAC/B,OAAO,CAACgC,SAAS,GAAGhC,OAAO,CAAC+B,GAAG;QACtC,CAAC,MAAM;UACL,MAAMlC,EAAE,CAACoB,qBAAqB,CAAC,aAAa,EAAE,QAAQ,EAAEjB,OAAO,CAAC+B,GAAG,CAAC;QACtE;MACF;MACA,IAAIlC,EAAE,CAACO,OAAO,CAACJ,OAAO,CAACiC,GAAG,CAAC,EAAE;QAC3B,IAAIpC,EAAE,CAACS,MAAM,CAACN,OAAO,CAACiC,GAAG,CAAC,EAAE;UAC1B,IAAI,CAACjC,OAAO,CAACkC,SAAS,GAAGlC,OAAO,CAACiC,GAAG;QACtC,CAAC,MAAM;UACL,MAAMpC,EAAE,CAACoB,qBAAqB,CAAC,aAAa,EAAE,QAAQ,EAAEjB,OAAO,CAACiC,GAAG,CAAC;QACtE;MACF;MACA,IAAIpC,EAAE,CAACO,OAAO,CAACJ,OAAO,CAACmC,GAAG,CAAC,EAAE;QAC3B,IAAItC,EAAE,CAACS,MAAM,CAACN,OAAO,CAACmC,GAAG,CAAC,EAAE;UAC1B,IAAI,CAACnC,OAAO,CAACoC,SAAS,GAAGpC,OAAO,CAACmC,GAAG;QACtC,CAAC,MAAM;UACL,MAAMtC,EAAE,CAACoB,qBAAqB,CAAC,aAAa,EAAE,QAAQ,EAAEjB,OAAO,CAACmC,GAAG,CAAC;QACtE;MACF;MACA,IAAItC,EAAE,CAACO,OAAO,CAACJ,OAAO,CAACqC,YAAY,CAAC,EAAE;QACpC,IAAIxC,EAAE,CAACyC,OAAO,CAACtC,OAAO,CAACqC,YAAY,EAAEE,MAAM,CAACC,MAAM,CAAC,IAAI,CAACC,WAAW,CAACC,aAAa,CAAC,CAAC,EAAE;UACnF,IAAI,CAAC1C,OAAO,CAAC2C,kBAAkB,GAAG3C,OAAO,CAACqC,YAAY;QACxD,CAAC,MAAM;UACL,MAAMxC,EAAE,CAACoB,qBAAqB,CAAC,sBAAsB,EAAE,yBAAyB,EAAEjB,OAAO,CAACqC,YAAY,CAAC;QACzG;MACF;IACF,CAAC,MAAM;MACL,MAAMxC,EAAE,CAACoB,qBAAqB,CAAC,SAAS,EAAE,QAAQ,EAAEjB,OAAO,CAAC;IAC9D;EACF;EAEA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4C,OAAOA,CAAE5C,OAAO,EAAE6C,IAAI,EAAEC,MAAM,EAAE;EACvC,IAAI,CAACjD,EAAE,CAACO,OAAO,CAACJ,OAAO,CAAC,EAAE;IACxB;IACA,IAAI,CAACA,OAAO,CAAC+C,YAAY,GAAG,CAAC,CAAC;EAChC,CAAC,MAAM,IAAIlD,EAAE,CAACsB,IAAI,CAACnB,OAAO,CAAC,EAAE;IAC3B;IACA,IAAI,CAACA,OAAO,CAAC+C,YAAY,GAAG/C,OAAO,GAAG,CAAC,CAAC,GAAG,CAAC;EAC9C,CAAC,MAAM,IAAIH,EAAE,CAACS,MAAM,CAACN,OAAO,CAAC,IAAIH,EAAE,CAACmD,OAAO,CAAChD,OAAO,EAAE,IAAI,EAAE,KAAK,CAAC,EAAE;IACjE;IACA,IAAI,CAACA,OAAO,CAAC+C,YAAY,GAAG/C,OAAO;IACnC;IACA,IAAIH,EAAE,CAACO,OAAO,CAACyC,IAAI,CAAC,EAAE;MACpB,IAAIhD,EAAE,CAACS,MAAM,CAACuC,IAAI,CAAC,IAAIhD,EAAE,CAACmD,OAAO,CAACH,IAAI,EAAE,CAAC,EAAE,KAAK,CAAC,EAAE;QACjD,IAAI,CAAC7C,OAAO,CAACiD,SAAS,GAAGJ,IAAI;MAC/B,CAAC,MAAM;QACL,MAAMhD,EAAE,CAACoB,qBAAqB,CAAC,MAAM,EAAE,4BAA4B,EAAE4B,IAAI,CAAC;MAC5E;IACF;IACA;IACA,IAAIhD,EAAE,CAACO,OAAO,CAAC0C,MAAM,CAAC,EAAE;MACtB,IAAIjD,EAAE,CAACS,MAAM,CAACwC,MAAM,CAAC,IAAIjD,EAAE,CAACmD,OAAO,CAACF,MAAM,EAAE,CAAC,EAAE,KAAK,CAAC,EAAE;QACrD,IAAI,CAAC9C,OAAO,CAACkD,SAAS,GAAGJ,MAAM;MACjC,CAAC,MAAM;QACL,MAAMjD,EAAE,CAACoB,qBAAqB,CAAC,QAAQ,EAAE,4BAA4B,EAAE6B,MAAM,CAAC;MAChF;IACF;EACF,CAAC,MAAM,IAAIjD,EAAE,CAACsD,WAAW,CAACnD,OAAO,CAAC,EAAE;IAClC,IAAIH,EAAE,CAACS,MAAM,CAACN,OAAO,CAACoD,KAAK,CAAC,IAAIvD,EAAE,CAACmD,OAAO,CAAChD,OAAO,CAACoD,KAAK,EAAE,QAAQ,EAAE,EAAE,CAAC,EAAE;MACvE,IAAI,CAACpD,OAAO,CAAC+C,YAAY,GAAG/C,OAAO,CAACoD,KAAK;IAC3C,CAAC,MAAM;MACL,MAAMvD,EAAE,CAACoB,qBAAqB,CAAC,eAAe,EAAE,gCAAgC,EAAEjB,OAAO,CAACoD,KAAK,CAAC;IAClG;IACA,IAAIvD,EAAE,CAACO,OAAO,CAACJ,OAAO,CAACqD,EAAE,CAAC,EAAE;MAC1B,IAAIxD,EAAE,CAACS,MAAM,CAACN,OAAO,CAACqD,EAAE,CAAC,IAAIxD,EAAE,CAACmD,OAAO,CAAChD,OAAO,CAACqD,EAAE,EAAE,CAAC,EAAE,OAAO,CAAC,EAAE;QAC/D,IAAI,CAACrD,OAAO,CAACiD,SAAS,GAAGjD,OAAO,CAACqD,EAAE;MACrC,CAAC,MAAM;QACL,MAAMxD,EAAE,CAACoB,qBAAqB,CAAC,YAAY,EAAE,8BAA8B,EAAEjB,OAAO,CAACqD,EAAE,CAAC;MAC1F;IACF;IACA,IAAIxD,EAAE,CAACO,OAAO,CAACJ,OAAO,CAACsD,EAAE,CAAC,EAAE;MAC1B,IAAIzD,EAAE,CAACS,MAAM,CAACN,OAAO,CAACsD,EAAE,CAAC,IAAIzD,EAAE,CAACmD,OAAO,CAAChD,OAAO,CAACsD,EAAE,EAAE,CAAC,EAAE,OAAO,CAAC,EAAE;QAC/D,IAAI,CAACtD,OAAO,CAACkD,SAAS,GAAGlD,OAAO,CAACsD,EAAE;MACrC,CAAC,MAAM;QACL,MAAMzD,EAAE,CAACoB,qBAAqB,CAAC,YAAY,EAAE,8BAA8B,EAAEjB,OAAO,CAACsD,EAAE,CAAC;MAC1F;IACF;IACA,IAAIzD,EAAE,CAACO,OAAO,CAACJ,OAAO,CAACuD,EAAE,CAAC,EAAE;MAC1B,IAAI1D,EAAE,CAACS,MAAM,CAACN,OAAO,CAACuD,EAAE,CAAC,IAAI1D,EAAE,CAACmD,OAAO,CAAChD,OAAO,CAACuD,EAAE,EAAE,CAAC,EAAE,OAAO,CAAC,EAAE;QAC/D,IAAI,CAACvD,OAAO,CAACwD,SAAS,GAAGxD,OAAO,CAACuD,EAAE;MACrC,CAAC,MAAM;QACL,MAAM1D,EAAE,CAACoB,qBAAqB,CAAC,YAAY,EAAE,8BAA8B,EAAEjB,OAAO,CAACuD,EAAE,CAAC;MAC1F;IACF;IACA,IAAI1D,EAAE,CAACO,OAAO,CAACJ,OAAO,CAACyD,EAAE,CAAC,EAAE;MAC1B,IAAI5D,EAAE,CAACS,MAAM,CAACN,OAAO,CAACyD,EAAE,CAAC,IAAI5D,EAAE,CAACmD,OAAO,CAAChD,OAAO,CAACyD,EAAE,EAAE,CAAC,EAAE,OAAO,CAAC,EAAE;QAC/D,IAAI,CAACzD,OAAO,CAAC0D,SAAS,GAAG1D,OAAO,CAACyD,EAAE;MACrC,CAAC,MAAM;QACL,MAAM5D,EAAE,CAACoB,qBAAqB,CAAC,YAAY,EAAE,8BAA8B,EAAEjB,OAAO,CAACyD,EAAE,CAAC;MAC1F;IACF;IACA,IAAI5D,EAAE,CAACO,OAAO,CAACJ,OAAO,CAAC2D,EAAE,CAAC,EAAE;MAC1B,IAAI9D,EAAE,CAACS,MAAM,CAACN,OAAO,CAAC2D,EAAE,CAAC,IAAI9D,EAAE,CAACmD,OAAO,CAAChD,OAAO,CAAC2D,EAAE,EAAE,CAAC,EAAE,OAAO,CAAC,EAAE;QAC/D,IAAI,CAAC3D,OAAO,CAAC4D,SAAS,GAAG5D,OAAO,CAAC2D,EAAE;MACrC,CAAC,MAAM;QACL,MAAM9D,EAAE,CAACoB,qBAAqB,CAAC,YAAY,EAAE,8BAA8B,EAAEjB,OAAO,CAAC2D,EAAE,CAAC;MAC1F;IACF;EACF,CAAC,MAAM;IACL,MAAM9D,EAAE,CAACoB,qBAAqB,CAAC,OAAO,EAAE,+BAA+B,EAAEjB,OAAO,CAAC;EACnF;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS6D,MAAMA,CAAEC,IAAI,EAAE;EACrB,IAAI,CAACjE,EAAE,CAACO,OAAO,CAAC0D,IAAI,CAAC,EAAE;IACrB;IACA,IAAI,CAAC9D,OAAO,CAAC+D,UAAU,GAAG,CAAC;EAC7B,CAAC,MAAM,IAAIlE,EAAE,CAACQ,OAAO,CAACyD,IAAI,CAAC,IAAIjE,EAAE,CAACmD,OAAO,CAACc,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE;IACxD;IACA,IAAI,CAAC9D,OAAO,CAAC+D,UAAU,GAAGD,IAAI;EAChC,CAAC,MAAM;IACL,MAAMjE,EAAE,CAACoB,qBAAqB,CAAC,MAAM,EAAE,4BAA4B,EAAE6C,IAAI,CAAC;EAC5E;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,IAAIA,CAAEZ,KAAK,EAAE;EACpB,IAAI,CAACvD,EAAE,CAACO,OAAO,CAACgD,KAAK,CAAC,EAAE;IACtB;IACA,IAAI,CAACpD,OAAO,CAACiE,SAAS,GAAG,CAAC,CAAC;EAC7B,CAAC,MAAM,IAAIpE,EAAE,CAACsB,IAAI,CAACiC,KAAK,CAAC,EAAE;IACzB;IACA,IAAI,CAACpD,OAAO,CAACiE,SAAS,GAAGb,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC;EACzC,CAAC,MAAM,IAAIvD,EAAE,CAACS,MAAM,CAAC8C,KAAK,CAAC,IAAIvD,EAAE,CAACmD,OAAO,CAACI,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE;IAC3D;IACA,IAAI,CAACpD,OAAO,CAACiE,SAAS,GAAGb,KAAK;EAChC,CAAC,MAAM;IACL,MAAMvD,EAAE,CAACoB,qBAAqB,CAAC,OAAO,EAAE,6BAA6B,EAAEmC,KAAK,CAAC;EAC/E;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASc,OAAOA,CAAElE,OAAO,EAAE;EACzB,IAAI,CAACA,OAAO,CAACkE,OAAO,GAAGrE,EAAE,CAACsB,IAAI,CAACnB,OAAO,CAAC,GAAGA,OAAO,GAAG,IAAI;EACxD,IAAIH,EAAE,CAACU,MAAM,CAACP,OAAO,CAAC,EAAE;IACtB,IAAI,CAAC4B,0BAA0B,CAAC,mBAAmB,EAAE5B,OAAO,CAACQ,UAAU,CAAC;EAC1E;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2D,SAASA,CAAA,EAAI;EACpB,IAAI,CAACnE,OAAO,CAACmE,SAAS,GAAG,IAAI;EAC7B,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,KAAKA,CAAEA,KAAK,EAAEC,QAAQ,EAAE;EAC/B,IAAI,CAACxE,EAAE,CAACO,OAAO,CAACgE,KAAK,CAAC,EAAE;IACtB;IACA,IAAI,CAACpE,OAAO,CAACoE,KAAK,GAAG,GAAG;EAC1B,CAAC,MAAM,IAAIvE,EAAE,CAACS,MAAM,CAAC8D,KAAK,CAAC,IAAIvE,EAAE,CAACmD,OAAO,CAACoB,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;IACtD,IAAI,CAACpE,OAAO,CAACoE,KAAK,GAAGA,KAAK;EAC5B,CAAC,MAAM;IACL,MAAMvE,EAAE,CAACoB,qBAAqB,CAAC,OAAO,EAAE,4BAA4B,EAAEmD,KAAK,CAAC;EAC9E;EACA,IAAI,CAACvE,EAAE,CAACO,OAAO,CAACiE,QAAQ,CAAC,EAAE;IACzB;IACA,IAAI,CAACrE,OAAO,CAACqE,QAAQ,GAAG,IAAI,CAACrE,OAAO,CAACoE,KAAK;EAC5C,CAAC,MAAM,IAAIvE,EAAE,CAACS,MAAM,CAAC+D,QAAQ,CAAC,IAAIxE,EAAE,CAACmD,OAAO,CAACqB,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE;IAC5D,IAAI,CAACrE,OAAO,CAACqE,QAAQ,GAAGA,QAAQ;EAClC,CAAC,MAAM;IACL,MAAMxE,EAAE,CAACoB,qBAAqB,CAAC,UAAU,EAAE,4BAA4B,EAAEoD,QAAQ,CAAC;EACpF;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAAEtE,OAAO,EAAE;EACxB,IAAI,CAACA,OAAO,CAACsE,MAAM,GAAGzE,EAAE,CAACsB,IAAI,CAACnB,OAAO,CAAC,GAAGA,OAAO,GAAG,IAAI;EACvD,IAAIH,EAAE,CAACsD,WAAW,CAACnD,OAAO,CAAC,IAAI,OAAO,IAAIA,OAAO,EAAE;IACjD,IAAI,CAACH,EAAE,CAACsB,IAAI,CAACnB,OAAO,CAACgB,KAAK,CAAC,EAAE;MAC3B,MAAMnB,EAAE,CAACoB,qBAAqB,CAAC,OAAO,EAAE,yBAAyB,EAAEjB,OAAO,CAACgB,KAAK,CAAC;IACnF,CAAC,MAAM;MACL,IAAI,CAAChB,OAAO,CAACuE,WAAW,GAAGvE,OAAO,CAACgB,KAAK;IAC1C;EACF;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwD,SAASA,CAAExE,OAAO,EAAE;EAC3B,IAAIH,EAAE,CAACsD,WAAW,CAACnD,OAAO,CAAC,EAAE;IAC3B,IAAIH,EAAE,CAACO,OAAO,CAACJ,OAAO,CAACyE,KAAK,CAAC,EAAE;MAC7B,IAAI5E,EAAE,CAACS,MAAM,CAACN,OAAO,CAACyE,KAAK,CAAC,IAAI5E,EAAE,CAACmD,OAAO,CAAChD,OAAO,CAACyE,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE;QAChE,IAAI,CAACzE,OAAO,CAAC0E,cAAc,GAAG1E,OAAO,CAACyE,KAAK;MAC7C,CAAC,MAAM;QACL,MAAM5E,EAAE,CAACoB,qBAAqB,CAAC,OAAO,EAAE,yBAAyB,EAAEjB,OAAO,CAACyE,KAAK,CAAC;MACnF;IACF;IACA,IAAI5E,EAAE,CAACO,OAAO,CAACJ,OAAO,CAAC2E,KAAK,CAAC,EAAE;MAC7B,IAAI9E,EAAE,CAACS,MAAM,CAACN,OAAO,CAAC2E,KAAK,CAAC,IAAI9E,EAAE,CAACmD,OAAO,CAAChD,OAAO,CAAC2E,KAAK,EAAE,CAAC,EAAE,GAAG,CAAC,EAAE;QACjE,IAAI,CAAC3E,OAAO,CAAC4E,cAAc,GAAG5E,OAAO,CAAC2E,KAAK;MAC7C,CAAC,MAAM;QACL,MAAM9E,EAAE,CAACoB,qBAAqB,CAAC,OAAO,EAAE,0BAA0B,EAAEjB,OAAO,CAAC2E,KAAK,CAAC;MACpF;IACF;EACF;EACA,IAAI,IAAI,CAAC3E,OAAO,CAAC0E,cAAc,IAAI,IAAI,CAAC1E,OAAO,CAAC4E,cAAc,EAAE;IAC9D,MAAM/E,EAAE,CAACoB,qBAAqB,CAAC,OAAO,EAAE,6BAA6B,EAClE,GAAE,IAAI,CAACjB,OAAO,CAAC0E,cAAe,OAAM,IAAI,CAAC1E,OAAO,CAAC4E,cAAe,EAAC,CAAC;EACvE;EACA,IAAI,CAAC5E,OAAO,CAACwE,SAAS,GAAG,IAAI;EAC7B,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,SAASA,CAAE7E,OAAO,EAAE;EAC3B,OAAO,IAAI,CAACwE,SAAS,CAACxE,OAAO,CAAC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS8E,KAAKA,CAAE9E,OAAO,EAAE;EACvB,IAAIH,EAAE,CAACsD,WAAW,CAACnD,OAAO,CAAC,EAAE;IAC3B,IAAIH,EAAE,CAACQ,OAAO,CAACL,OAAO,CAAC+E,KAAK,CAAC,IAAI/E,OAAO,CAAC+E,KAAK,GAAG,CAAC,EAAE;MAClD,IAAI,CAAC/E,OAAO,CAACgF,UAAU,GAAGhF,OAAO,CAAC+E,KAAK;IACzC,CAAC,MAAM;MACL,MAAMlF,EAAE,CAACoB,qBAAqB,CAAC,OAAO,EAAE,2BAA2B,EAAEjB,OAAO,CAAC+E,KAAK,CAAC;IACrF;IACA,IAAIlF,EAAE,CAACQ,OAAO,CAACL,OAAO,CAACiF,MAAM,CAAC,IAAIjF,OAAO,CAACiF,MAAM,GAAG,CAAC,EAAE;MACpD,IAAI,CAACjF,OAAO,CAACkF,WAAW,GAAGlF,OAAO,CAACiF,MAAM;IAC3C,CAAC,MAAM;MACL,MAAMpF,EAAE,CAACoB,qBAAqB,CAAC,QAAQ,EAAE,2BAA2B,EAAEjB,OAAO,CAACiF,MAAM,CAAC;IACvF;IACA,IAAIpF,EAAE,CAACO,OAAO,CAACJ,OAAO,CAACmF,QAAQ,CAAC,EAAE;MAChC,IAAItF,EAAE,CAACQ,OAAO,CAACL,OAAO,CAACmF,QAAQ,CAAC,IAAItF,EAAE,CAACmD,OAAO,CAAChD,OAAO,CAACmF,QAAQ,EAAE,CAAC,EAAE,GAAG,CAAC,EAAE;QACxE,IAAI,CAACnF,OAAO,CAACoF,aAAa,GAAGpF,OAAO,CAACmF,QAAQ;MAC/C,CAAC,MAAM;QACL,MAAMtF,EAAE,CAACoB,qBAAqB,CAAC,UAAU,EAAE,2BAA2B,EAAEjB,OAAO,CAACmF,QAAQ,CAAC;MAC3F;IACF;EACF,CAAC,MAAM;IACL,MAAMtF,EAAE,CAACoB,qBAAqB,CAAC,SAAS,EAAE,cAAc,EAAEjB,OAAO,CAAC;EACpE;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASqF,QAAQA,CAAEC,MAAM,EAAE;EACzB,IAAI,CAACzF,EAAE,CAACU,MAAM,CAAC+E,MAAM,CAAC,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,MAAM,CAACA,MAAM,CAAC,IACnD,CAACzF,EAAE,CAACQ,OAAO,CAACiF,MAAM,CAACP,KAAK,CAAC,IAAI,CAAClF,EAAE,CAACQ,OAAO,CAACiF,MAAM,CAACL,MAAM,CAAC,IACvD,CAACpF,EAAE,CAACmD,OAAO,CAACsC,MAAM,CAACP,KAAK,EAAE,CAAC,EAAE,IAAI,CAAC,IAAI,CAAClF,EAAE,CAACmD,OAAO,CAACsC,MAAM,CAACL,MAAM,EAAE,CAAC,EAAE,IAAI,CAAC,IACzEK,MAAM,CAACL,MAAM,GAAGK,MAAM,CAACP,KAAK,KAAKO,MAAM,CAACA,MAAM,CAAC7D,MAAM,EACvD;IACA;IACA,MAAM,IAAIgE,KAAK,CAAC,4BAA4B,CAAC;EAC/C;EACA;EACA,IAAI,CAAC5F,EAAE,CAACQ,OAAO,CAACiF,MAAM,CAACI,KAAK,CAAC,EAAE;IAC7BJ,MAAM,CAACI,KAAK,GAAGJ,MAAM,CAACA,MAAM,CAACK,MAAM,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;MAClD,OAAOD,CAAC,GAAGC,CAAC;IACd,CAAC,EAAE,CAAC,CAAC;EACP;EACA;EACA,IAAIP,MAAM,CAACI,KAAK,GAAG,CAAC,EAAE;IACpBJ,MAAM,CAACI,KAAK,GAAG,CAAC;EAClB;EACA,IAAI,CAAC7F,EAAE,CAACQ,OAAO,CAACiF,MAAM,CAACQ,MAAM,CAAC,EAAE;IAC9BR,MAAM,CAACQ,MAAM,GAAG,CAAC;EACnB;EACA,IAAI,CAAC9F,OAAO,CAAC+F,UAAU,GAAGT,MAAM;EAChC,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,SAASA,CAAEA,SAAS,EAAEhG,OAAO,EAAE;EACtC,IAAI,CAACH,EAAE,CAACO,OAAO,CAAC4F,SAAS,CAAC,EAAE;IAC1B,IAAI,CAAChG,OAAO,CAACgG,SAAS,GAAG,GAAG;EAC9B,CAAC,MAAM,IAAInG,EAAE,CAACsB,IAAI,CAAC6E,SAAS,CAAC,EAAE;IAC7B,IAAI,CAAChG,OAAO,CAACgG,SAAS,GAAGA,SAAS,GAAG,GAAG,GAAG,CAAC;EAC9C,CAAC,MAAM,IAAInG,EAAE,CAACQ,OAAO,CAAC2F,SAAS,CAAC,IAAInG,EAAE,CAACmD,OAAO,CAACgD,SAAS,EAAE,CAAC,EAAE,GAAG,CAAC,EAAE;IACjE,IAAI,CAAChG,OAAO,CAACgG,SAAS,GAAGA,SAAS;EACpC,CAAC,MAAM;IACL,MAAMnG,EAAE,CAACoB,qBAAqB,CAAC,WAAW,EAAE,2BAA2B,EAAE+E,SAAS,CAAC;EACrF;EACA,IAAI,CAACnG,EAAE,CAACU,MAAM,CAACP,OAAO,CAAC,IAAIA,OAAO,CAACiG,SAAS,KAAK,IAAI,IAAIjG,OAAO,CAACkG,SAAS,KAAK,IAAI,EAAE;IACnF,IAAI,CAAClG,OAAO,CAACmG,kBAAkB,GAAG,IAAI;EACxC,CAAC,MAAM;IACL,IAAI,CAACnG,OAAO,CAACmG,kBAAkB,GAAG,KAAK;EACzC;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,OAAOA,CAAEC,OAAO,EAAEC,QAAQ,EAAEtG,OAAO,EAAE;EAC5C,IAAI,CAACA,OAAO,CAACoG,OAAO,GAAG,IAAI,CAACG,sBAAsB,CAACF,OAAO,EAAErG,OAAO,CAAC;EACpE,IAAIH,EAAE,CAAC2G,MAAM,CAACF,QAAQ,CAAC,IAAIzG,EAAE,CAACyC,OAAO,CAACgE,QAAQ,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,EAAE;IACrE,IAAI,CAACtG,OAAO,CAACyG,SAAS,GAAGH,QAAQ;EACnC,CAAC,MAAM;IACL,MAAMzG,EAAE,CAACoB,qBAAqB,CAAC,UAAU,EAAE,sBAAsB,EAAEqF,QAAQ,CAAC;EAC9E;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,MAAMA,CAAEd,CAAC,EAAEC,CAAC,EAAE;EACrB,IAAI,CAAChG,EAAE,CAACO,OAAO,CAACwF,CAAC,CAAC,IAAI/F,EAAE,CAACS,MAAM,CAACuF,CAAC,CAAC,EAAE;IAClCD,CAAC,GAAG,GAAG;EACT,CAAC,MAAM,IAAI/F,EAAE,CAACS,MAAM,CAACsF,CAAC,CAAC,IAAI,CAAC/F,EAAE,CAACO,OAAO,CAACyF,CAAC,CAAC,EAAE;IACzCA,CAAC,GAAG,GAAG;EACT;EACA,IAAI,CAAChG,EAAE,CAACO,OAAO,CAACwF,CAAC,CAAC,EAAE;IAClB,IAAI,CAAC5F,OAAO,CAAC2G,OAAO,GAAG,EAAE;EAC3B,CAAC,MAAM,IAAI9G,EAAE,CAACS,MAAM,CAACsF,CAAC,CAAC,EAAE;IACvB,IAAI,CAAC5F,OAAO,CAAC2G,OAAO,GAAG,CAACf,CAAC,CAAC;EAC5B,CAAC,MAAM,IAAIL,KAAK,CAACC,OAAO,CAACI,CAAC,CAAC,IAAIA,CAAC,CAACnE,MAAM,IAAImE,CAAC,CAAClE,KAAK,CAAC7B,EAAE,CAACS,MAAM,CAAC,EAAE;IAC7D,IAAI,CAACN,OAAO,CAAC2G,OAAO,GAAGf,CAAC;EAC1B,CAAC,MAAM;IACL,MAAM/F,EAAE,CAACoB,qBAAqB,CAAC,GAAG,EAAE,4BAA4B,EAAE2E,CAAC,CAAC;EACtE;EACA,IAAI,CAAC/F,EAAE,CAACO,OAAO,CAACyF,CAAC,CAAC,EAAE;IAClB,IAAI,CAAC7F,OAAO,CAAC4G,OAAO,GAAG,EAAE;EAC3B,CAAC,MAAM,IAAI/G,EAAE,CAACS,MAAM,CAACuF,CAAC,CAAC,EAAE;IACvB,IAAI,CAAC7F,OAAO,CAAC4G,OAAO,GAAG,CAACf,CAAC,CAAC;EAC5B,CAAC,MAAM,IAAIN,KAAK,CAACC,OAAO,CAACK,CAAC,CAAC,IAAIA,CAAC,CAACpE,MAAM,IAAIoE,CAAC,CAACnE,KAAK,CAAC7B,EAAE,CAACS,MAAM,CAAC,EAAE;IAC7D,IAAI,CAACN,OAAO,CAAC4G,OAAO,GAAGf,CAAC;EAC1B,CAAC,MAAM;IACL,MAAMhG,EAAE,CAACoB,qBAAqB,CAAC,GAAG,EAAE,4BAA4B,EAAE4E,CAAC,CAAC;EACtE;EACA,IAAI,IAAI,CAAC7F,OAAO,CAAC2G,OAAO,CAAClF,MAAM,KAAK,IAAI,CAACzB,OAAO,CAAC4G,OAAO,CAACnF,MAAM,EAAE;IAC/D,MAAM,IAAIgE,KAAK,CAAC,kDAAkD,CAAC;EACrE;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoB,MAAMA,CAAEC,WAAW,EAAE;EAC5B,IAAI,CAACvB,KAAK,CAACC,OAAO,CAACsB,WAAW,CAAC,IAAIA,WAAW,CAACrF,MAAM,KAAK,CAAC,IACvDqF,WAAW,CAAC,CAAC,CAAC,CAACrF,MAAM,KAAK,CAAC,IAC3BqF,WAAW,CAAC,CAAC,CAAC,CAACrF,MAAM,KAAK,CAAC,IAC3BqF,WAAW,CAAC,CAAC,CAAC,CAACrF,MAAM,KAAK,CAAC,EAC7B;IACA;IACA,MAAM,IAAIgE,KAAK,CAAC,8BAA8B,CAAC;EACjD;EACA,IAAI,CAACzF,OAAO,CAAC+G,YAAY,GAAG,CAC1BD,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EACvDA,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EACvDA,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACxD,CAACE,GAAG,CAACC,MAAM,CAAC;EACb,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,QAAQA,CAAElH,OAAO,EAAE;EAC1B,IAAI,CAACH,EAAE,CAACsD,WAAW,CAACnD,OAAO,CAAC,EAAE;IAC5B,MAAMH,EAAE,CAACoB,qBAAqB,CAAC,SAAS,EAAE,cAAc,EAAEjB,OAAO,CAAC;EACpE;EACA,IAAI,YAAY,IAAIA,OAAO,EAAE;IAC3B,IAAIH,EAAE,CAACS,MAAM,CAACN,OAAO,CAACmH,UAAU,CAAC,IAAInH,OAAO,CAACmH,UAAU,IAAI,CAAC,EAAE;MAC5D,IAAI,CAACnH,OAAO,CAACmH,UAAU,GAAGnH,OAAO,CAACmH,UAAU;IAC9C,CAAC,MAAM;MACL,MAAMtH,EAAE,CAACoB,qBAAqB,CAAC,YAAY,EAAE,mBAAmB,EAAEjB,OAAO,CAACmH,UAAU,CAAC;IACvF;EACF;EACA,IAAI,YAAY,IAAInH,OAAO,EAAE;IAC3B,IAAIH,EAAE,CAACS,MAAM,CAACN,OAAO,CAACoH,UAAU,CAAC,IAAIpH,OAAO,CAACoH,UAAU,IAAI,CAAC,EAAE;MAC5D,IAAI,CAACpH,OAAO,CAACoH,UAAU,GAAGpH,OAAO,CAACoH,UAAU;IAC9C,CAAC,MAAM;MACL,MAAMvH,EAAE,CAACoB,qBAAqB,CAAC,YAAY,EAAE,mBAAmB,EAAEjB,OAAO,CAACoH,UAAU,CAAC;IACvF;EACF;EACA,IAAI,KAAK,IAAIpH,OAAO,EAAE;IACpB,IAAIH,EAAE,CAACQ,OAAO,CAACL,OAAO,CAACqH,GAAG,CAAC,EAAE;MAC3B,IAAI,CAACrH,OAAO,CAACqH,GAAG,GAAGrH,OAAO,CAACqH,GAAG,GAAG,GAAG;IACtC,CAAC,MAAM;MACL,MAAMxH,EAAE,CAACoB,qBAAqB,CAAC,KAAK,EAAE,QAAQ,EAAEjB,OAAO,CAACqH,GAAG,CAAC;IAC9D;EACF;EACA,IAAI,WAAW,IAAIrH,OAAO,EAAE;IAC1B,IAAIH,EAAE,CAACS,MAAM,CAACN,OAAO,CAACsH,SAAS,CAAC,EAAE;MAChC,IAAI,CAACtH,OAAO,CAACsH,SAAS,GAAGtH,OAAO,CAACsH,SAAS;IAC5C,CAAC,MAAM;MACL,MAAMzH,EAAE,CAACoB,qBAAqB,CAAC,WAAW,EAAE,QAAQ,EAAEjB,OAAO,CAACsH,SAAS,CAAC;IAC1E;EACF;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG,UAAUC,KAAK,EAAE;EAChClF,MAAM,CAACmF,MAAM,CAACD,KAAK,CAACE,SAAS,EAAE;IAC7B7H,MAAM;IACNoB,IAAI;IACJE,IAAI;IACJC,MAAM;IACNuB,OAAO;IACPiB,MAAM;IACNG,IAAI;IACJE,OAAO;IACPC,SAAS;IACTC,KAAK;IACLE,MAAM;IACNE,SAAS;IACTK,SAAS;IACTC,KAAK;IACLO,QAAQ;IACRW,SAAS;IACTI,OAAO;IACPM,MAAM;IACNG,MAAM;IACNK;EACF,CAAC,CAAC;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}