{"ast":null,"code":"// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst color = require('color');\nconst is = require('./is');\nconst sharp = require('./sharp');\n\n/**\n * Justication alignment\n * @member\n * @private\n */\nconst align = {\n  left: 'low',\n  center: 'centre',\n  centre: 'centre',\n  right: 'high'\n};\n\n/**\n * Extract input options, if any, from an object.\n * @private\n */\nfunction _inputOptionsFromObject(obj) {\n  const {\n    raw,\n    density,\n    limitInputPixels,\n    ignoreIcc,\n    unlimited,\n    sequentialRead,\n    failOn,\n    failOnError,\n    animated,\n    page,\n    pages,\n    subifd\n  } = obj;\n  return [raw, density, limitInputPixels, ignoreIcc, unlimited, sequentialRead, failOn, failOnError, animated, page, pages, subifd].some(is.defined) ? {\n    raw,\n    density,\n    limitInputPixels,\n    ignoreIcc,\n    unlimited,\n    sequentialRead,\n    failOn,\n    failOnError,\n    animated,\n    page,\n    pages,\n    subifd\n  } : undefined;\n}\n\n/**\n * Create Object containing input and input-related options.\n * @private\n */\nfunction _createInputDescriptor(input, inputOptions, containerOptions) {\n  const inputDescriptor = {\n    failOn: 'warning',\n    limitInputPixels: Math.pow(0x3FFF, 2),\n    ignoreIcc: false,\n    unlimited: false,\n    sequentialRead: true\n  };\n  if (is.string(input)) {\n    // filesystem\n    inputDescriptor.file = input;\n  } else if (is.buffer(input)) {\n    // Buffer\n    if (input.length === 0) {\n      throw Error('Input Buffer is empty');\n    }\n    inputDescriptor.buffer = input;\n  } else if (is.arrayBuffer(input)) {\n    if (input.byteLength === 0) {\n      throw Error('Input bit Array is empty');\n    }\n    inputDescriptor.buffer = Buffer.from(input, 0, input.byteLength);\n  } else if (is.typedArray(input)) {\n    if (input.length === 0) {\n      throw Error('Input Bit Array is empty');\n    }\n    inputDescriptor.buffer = Buffer.from(input.buffer, input.byteOffset, input.byteLength);\n  } else if (is.plainObject(input) && !is.defined(inputOptions)) {\n    // Plain Object descriptor, e.g. create\n    inputOptions = input;\n    if (_inputOptionsFromObject(inputOptions)) {\n      // Stream with options\n      inputDescriptor.buffer = [];\n    }\n  } else if (!is.defined(input) && !is.defined(inputOptions) && is.object(containerOptions) && containerOptions.allowStream) {\n    // Stream without options\n    inputDescriptor.buffer = [];\n  } else {\n    throw new Error(`Unsupported input '${input}' of type ${typeof input}${is.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ''}`);\n  }\n  if (is.object(inputOptions)) {\n    // Deprecated: failOnError\n    if (is.defined(inputOptions.failOnError)) {\n      if (is.bool(inputOptions.failOnError)) {\n        inputDescriptor.failOn = inputOptions.failOnError ? 'warning' : 'none';\n      } else {\n        throw is.invalidParameterError('failOnError', 'boolean', inputOptions.failOnError);\n      }\n    }\n    // failOn\n    if (is.defined(inputOptions.failOn)) {\n      if (is.string(inputOptions.failOn) && is.inArray(inputOptions.failOn, ['none', 'truncated', 'error', 'warning'])) {\n        inputDescriptor.failOn = inputOptions.failOn;\n      } else {\n        throw is.invalidParameterError('failOn', 'one of: none, truncated, error, warning', inputOptions.failOn);\n      }\n    }\n    // Density\n    if (is.defined(inputOptions.density)) {\n      if (is.inRange(inputOptions.density, 1, 100000)) {\n        inputDescriptor.density = inputOptions.density;\n      } else {\n        throw is.invalidParameterError('density', 'number between 1 and 100000', inputOptions.density);\n      }\n    }\n    // Ignore embeddded ICC profile\n    if (is.defined(inputOptions.ignoreIcc)) {\n      if (is.bool(inputOptions.ignoreIcc)) {\n        inputDescriptor.ignoreIcc = inputOptions.ignoreIcc;\n      } else {\n        throw is.invalidParameterError('ignoreIcc', 'boolean', inputOptions.ignoreIcc);\n      }\n    }\n    // limitInputPixels\n    if (is.defined(inputOptions.limitInputPixels)) {\n      if (is.bool(inputOptions.limitInputPixels)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels ? Math.pow(0x3FFF, 2) : 0;\n      } else if (is.integer(inputOptions.limitInputPixels) && is.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;\n      } else {\n        throw is.invalidParameterError('limitInputPixels', 'positive integer', inputOptions.limitInputPixels);\n      }\n    }\n    // unlimited\n    if (is.defined(inputOptions.unlimited)) {\n      if (is.bool(inputOptions.unlimited)) {\n        inputDescriptor.unlimited = inputOptions.unlimited;\n      } else {\n        throw is.invalidParameterError('unlimited', 'boolean', inputOptions.unlimited);\n      }\n    }\n    // sequentialRead\n    if (is.defined(inputOptions.sequentialRead)) {\n      if (is.bool(inputOptions.sequentialRead)) {\n        inputDescriptor.sequentialRead = inputOptions.sequentialRead;\n      } else {\n        throw is.invalidParameterError('sequentialRead', 'boolean', inputOptions.sequentialRead);\n      }\n    }\n    // Raw pixel input\n    if (is.defined(inputOptions.raw)) {\n      if (is.object(inputOptions.raw) && is.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 && is.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 && is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)) {\n        inputDescriptor.rawWidth = inputOptions.raw.width;\n        inputDescriptor.rawHeight = inputOptions.raw.height;\n        inputDescriptor.rawChannels = inputOptions.raw.channels;\n        inputDescriptor.rawPremultiplied = !!inputOptions.raw.premultiplied;\n        switch (input.constructor) {\n          case Uint8Array:\n          case Uint8ClampedArray:\n            inputDescriptor.rawDepth = 'uchar';\n            break;\n          case Int8Array:\n            inputDescriptor.rawDepth = 'char';\n            break;\n          case Uint16Array:\n            inputDescriptor.rawDepth = 'ushort';\n            break;\n          case Int16Array:\n            inputDescriptor.rawDepth = 'short';\n            break;\n          case Uint32Array:\n            inputDescriptor.rawDepth = 'uint';\n            break;\n          case Int32Array:\n            inputDescriptor.rawDepth = 'int';\n            break;\n          case Float32Array:\n            inputDescriptor.rawDepth = 'float';\n            break;\n          case Float64Array:\n            inputDescriptor.rawDepth = 'double';\n            break;\n          default:\n            inputDescriptor.rawDepth = 'uchar';\n            break;\n        }\n      } else {\n        throw new Error('Expected width, height and channels for raw pixel input');\n      }\n    }\n    // Multi-page input (GIF, TIFF, PDF)\n    if (is.defined(inputOptions.animated)) {\n      if (is.bool(inputOptions.animated)) {\n        inputDescriptor.pages = inputOptions.animated ? -1 : 1;\n      } else {\n        throw is.invalidParameterError('animated', 'boolean', inputOptions.animated);\n      }\n    }\n    if (is.defined(inputOptions.pages)) {\n      if (is.integer(inputOptions.pages) && is.inRange(inputOptions.pages, -1, 100000)) {\n        inputDescriptor.pages = inputOptions.pages;\n      } else {\n        throw is.invalidParameterError('pages', 'integer between -1 and 100000', inputOptions.pages);\n      }\n    }\n    if (is.defined(inputOptions.page)) {\n      if (is.integer(inputOptions.page) && is.inRange(inputOptions.page, 0, 100000)) {\n        inputDescriptor.page = inputOptions.page;\n      } else {\n        throw is.invalidParameterError('page', 'integer between 0 and 100000', inputOptions.page);\n      }\n    }\n    // Multi-level input (OpenSlide)\n    if (is.defined(inputOptions.level)) {\n      if (is.integer(inputOptions.level) && is.inRange(inputOptions.level, 0, 256)) {\n        inputDescriptor.level = inputOptions.level;\n      } else {\n        throw is.invalidParameterError('level', 'integer between 0 and 256', inputOptions.level);\n      }\n    }\n    // Sub Image File Directory (TIFF)\n    if (is.defined(inputOptions.subifd)) {\n      if (is.integer(inputOptions.subifd) && is.inRange(inputOptions.subifd, -1, 100000)) {\n        inputDescriptor.subifd = inputOptions.subifd;\n      } else {\n        throw is.invalidParameterError('subifd', 'integer between -1 and 100000', inputOptions.subifd);\n      }\n    }\n    // Create new image\n    if (is.defined(inputOptions.create)) {\n      if (is.object(inputOptions.create) && is.integer(inputOptions.create.width) && inputOptions.create.width > 0 && is.integer(inputOptions.create.height) && inputOptions.create.height > 0 && is.integer(inputOptions.create.channels)) {\n        inputDescriptor.createWidth = inputOptions.create.width;\n        inputDescriptor.createHeight = inputOptions.create.height;\n        inputDescriptor.createChannels = inputOptions.create.channels;\n        // Noise\n        if (is.defined(inputOptions.create.noise)) {\n          if (!is.object(inputOptions.create.noise)) {\n            throw new Error('Expected noise to be an object');\n          }\n          if (!is.inArray(inputOptions.create.noise.type, ['gaussian'])) {\n            throw new Error('Only gaussian noise is supported at the moment');\n          }\n          if (!is.inRange(inputOptions.create.channels, 1, 4)) {\n            throw is.invalidParameterError('create.channels', 'number between 1 and 4', inputOptions.create.channels);\n          }\n          inputDescriptor.createNoiseType = inputOptions.create.noise.type;\n          if (is.number(inputOptions.create.noise.mean) && is.inRange(inputOptions.create.noise.mean, 0, 10000)) {\n            inputDescriptor.createNoiseMean = inputOptions.create.noise.mean;\n          } else {\n            throw is.invalidParameterError('create.noise.mean', 'number between 0 and 10000', inputOptions.create.noise.mean);\n          }\n          if (is.number(inputOptions.create.noise.sigma) && is.inRange(inputOptions.create.noise.sigma, 0, 10000)) {\n            inputDescriptor.createNoiseSigma = inputOptions.create.noise.sigma;\n          } else {\n            throw is.invalidParameterError('create.noise.sigma', 'number between 0 and 10000', inputOptions.create.noise.sigma);\n          }\n        } else if (is.defined(inputOptions.create.background)) {\n          if (!is.inRange(inputOptions.create.channels, 3, 4)) {\n            throw is.invalidParameterError('create.channels', 'number between 3 and 4', inputOptions.create.channels);\n          }\n          const background = color(inputOptions.create.background);\n          inputDescriptor.createBackground = [background.red(), background.green(), background.blue(), Math.round(background.alpha() * 255)];\n        } else {\n          throw new Error('Expected valid noise or background to create a new input image');\n        }\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected valid width, height and channels to create a new input image');\n      }\n    }\n    // Create a new image with text\n    if (is.defined(inputOptions.text)) {\n      if (is.object(inputOptions.text) && is.string(inputOptions.text.text)) {\n        inputDescriptor.textValue = inputOptions.text.text;\n        if (is.defined(inputOptions.text.height) && is.defined(inputOptions.text.dpi)) {\n          throw new Error('Expected only one of dpi or height');\n        }\n        if (is.defined(inputOptions.text.font)) {\n          if (is.string(inputOptions.text.font)) {\n            inputDescriptor.textFont = inputOptions.text.font;\n          } else {\n            throw is.invalidParameterError('text.font', 'string', inputOptions.text.font);\n          }\n        }\n        if (is.defined(inputOptions.text.fontfile)) {\n          if (is.string(inputOptions.text.fontfile)) {\n            inputDescriptor.textFontfile = inputOptions.text.fontfile;\n          } else {\n            throw is.invalidParameterError('text.fontfile', 'string', inputOptions.text.fontfile);\n          }\n        }\n        if (is.defined(inputOptions.text.width)) {\n          if (is.number(inputOptions.text.width)) {\n            inputDescriptor.textWidth = inputOptions.text.width;\n          } else {\n            throw is.invalidParameterError('text.textWidth', 'number', inputOptions.text.width);\n          }\n        }\n        if (is.defined(inputOptions.text.height)) {\n          if (is.number(inputOptions.text.height)) {\n            inputDescriptor.textHeight = inputOptions.text.height;\n          } else {\n            throw is.invalidParameterError('text.height', 'number', inputOptions.text.height);\n          }\n        }\n        if (is.defined(inputOptions.text.align)) {\n          if (is.string(inputOptions.text.align) && is.string(this.constructor.align[inputOptions.text.align])) {\n            inputDescriptor.textAlign = this.constructor.align[inputOptions.text.align];\n          } else {\n            throw is.invalidParameterError('text.align', 'valid alignment', inputOptions.text.align);\n          }\n        }\n        if (is.defined(inputOptions.text.justify)) {\n          if (is.bool(inputOptions.text.justify)) {\n            inputDescriptor.textJustify = inputOptions.text.justify;\n          } else {\n            throw is.invalidParameterError('text.justify', 'boolean', inputOptions.text.justify);\n          }\n        }\n        if (is.defined(inputOptions.text.dpi)) {\n          if (is.number(inputOptions.text.dpi) && is.inRange(inputOptions.text.dpi, 1, 100000)) {\n            inputDescriptor.textDpi = inputOptions.text.dpi;\n          } else {\n            throw is.invalidParameterError('text.dpi', 'number between 1 and 100000', inputOptions.text.dpi);\n          }\n        }\n        if (is.defined(inputOptions.text.rgba)) {\n          if (is.bool(inputOptions.text.rgba)) {\n            inputDescriptor.textRgba = inputOptions.text.rgba;\n          } else {\n            throw is.invalidParameterError('text.rgba', 'bool', inputOptions.text.rgba);\n          }\n        }\n        if (is.defined(inputOptions.text.spacing)) {\n          if (is.number(inputOptions.text.spacing)) {\n            inputDescriptor.textSpacing = inputOptions.text.spacing;\n          } else {\n            throw is.invalidParameterError('text.spacing', 'number', inputOptions.text.spacing);\n          }\n        }\n        if (is.defined(inputOptions.text.wrap)) {\n          if (is.string(inputOptions.text.wrap) && is.inArray(inputOptions.text.wrap, ['word', 'char', 'wordChar', 'none'])) {\n            inputDescriptor.textWrap = inputOptions.text.wrap;\n          } else {\n            throw is.invalidParameterError('text.wrap', 'one of: word, char, wordChar, none', inputOptions.text.wrap);\n          }\n        }\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected a valid string to create an image with text.');\n      }\n    }\n  } else if (is.defined(inputOptions)) {\n    throw new Error('Invalid input options ' + inputOptions);\n  }\n  return inputDescriptor;\n}\n\n/**\n * Handle incoming Buffer chunk on Writable Stream.\n * @private\n * @param {Buffer} chunk\n * @param {string} encoding - unused\n * @param {Function} callback\n */\nfunction _write(chunk, encoding, callback) {\n  /* istanbul ignore else */\n  if (Array.isArray(this.options.input.buffer)) {\n    /* istanbul ignore else */\n    if (is.buffer(chunk)) {\n      if (this.options.input.buffer.length === 0) {\n        this.on('finish', () => {\n          this.streamInFinished = true;\n        });\n      }\n      this.options.input.buffer.push(chunk);\n      callback();\n    } else {\n      callback(new Error('Non-Buffer data on Writable Stream'));\n    }\n  } else {\n    callback(new Error('Unexpected data on Writable Stream'));\n  }\n}\n\n/**\n * Flattens the array of chunks accumulated in input.buffer.\n * @private\n */\nfunction _flattenBufferIn() {\n  if (this._isStreamInput()) {\n    this.options.input.buffer = Buffer.concat(this.options.input.buffer);\n  }\n}\n\n/**\n * Are we expecting Stream-based input?\n * @private\n * @returns {boolean}\n */\nfunction _isStreamInput() {\n  return Array.isArray(this.options.input.buffer);\n}\n\n/**\n * Fast access to (uncached) image metadata without decoding any compressed pixel data.\n *\n * This is read from the header of the input image.\n * It does not take into consideration any operations to be applied to the output image,\n * such as resize or rotate.\n *\n * Dimensions in the response will respect the `page` and `pages` properties of the\n * {@link /api-constructor#parameters|constructor parameters}.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `format`: Name of decoder used to decompress image data e.g. `jpeg`, `png`, `webp`, `gif`, `svg`\n * - `size`: Total size of image in bytes, for Stream and Buffer input only\n * - `width`: Number of pixels wide (EXIF orientation is not taken into consideration, see example below)\n * - `height`: Number of pixels high (EXIF orientation is not taken into consideration, see example below)\n * - `space`: Name of colour space interpretation e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://www.libvips.org/API/current/VipsImage.html#VipsInterpretation)\n * - `channels`: Number of bands e.g. `3` for sRGB, `4` for CMYK\n * - `depth`: Name of pixel depth format e.g. `uchar`, `char`, `ushort`, `float` [...](https://www.libvips.org/API/current/VipsImage.html#VipsBandFormat)\n * - `density`: Number of pixels per inch (DPI), if present\n * - `chromaSubsampling`: String containing JPEG chroma subsampling, `4:2:0` or `4:4:4` for RGB, `4:2:0:4` or `4:4:4:4` for CMYK\n * - `isProgressive`: Boolean indicating whether the image is interlaced using a progressive scan\n * - `pages`: Number of pages/frames contained within the image, with support for TIFF, HEIF, PDF, animated GIF and animated WebP\n * - `pageHeight`: Number of pixels high each page in a multi-page image will be.\n * - `loop`: Number of times to loop an animated image, zero refers to a continuous loop.\n * - `delay`: Delay in ms between each page in an animated image, provided as an array of integers.\n * - `pagePrimary`: Number of the primary page in a HEIF image\n * - `levels`: Details of each level in a multi-level image provided as an array of objects, requires libvips compiled with support for OpenSlide\n * - `subifds`: Number of Sub Image File Directories in an OME-TIFF image\n * - `background`: Default background colour, if present, for PNG (bKGD) and GIF images, either an RGB Object or a single greyscale value\n * - `compression`: The encoder used to compress an HEIF file, `av1` (AVIF) or `hevc` (HEIC)\n * - `resolutionUnit`: The unit of resolution (density), either `inch` or `cm`, if present\n * - `hasProfile`: Boolean indicating the presence of an embedded ICC profile\n * - `hasAlpha`: Boolean indicating the presence of an alpha transparency channel\n * - `orientation`: Number value of the EXIF Orientation header, if present\n * - `exif`: Buffer containing raw EXIF data, if present\n * - `icc`: Buffer containing raw [ICC](https://www.npmjs.com/package/icc) profile data, if present\n * - `iptc`: Buffer containing raw IPTC data, if present\n * - `xmp`: Buffer containing raw XMP data, if present\n * - `tifftagPhotoshop`: Buffer containing raw TIFFTAG_PHOTOSHOP data, if present\n * - `formatMagick`: String containing format for images loaded via *magick\n *\n * @example\n * const metadata = await sharp(input).metadata();\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .metadata()\n *   .then(function(metadata) {\n *     return image\n *       .resize(Math.round(metadata.width / 2))\n *       .webp()\n *       .toBuffer();\n *   })\n *   .then(function(data) {\n *     // data contains a WebP image half the width and height of the original JPEG\n *   });\n *\n * @example\n * // Based on EXIF rotation metadata, get the right-side-up width and height:\n *\n * const size = getNormalSize(await sharp(input).metadata());\n *\n * function getNormalSize({ width, height, orientation }) {\n *   return (orientation || 0) >= 5\n *     ? { width: height, height: width }\n *     : { width, height };\n * }\n *\n * @param {Function} [callback] - called with the arguments `(err, metadata)`\n * @returns {Promise<Object>|Sharp}\n */\nfunction metadata(callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.metadata(this.options, callback);\n      });\n    } else {\n      sharp.metadata(this.options, callback);\n    }\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        const finished = () => {\n          this._flattenBufferIn();\n          sharp.metadata(this.options, (err, metadata) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(metadata);\n            }\n          });\n        };\n        if (this.writableFinished) {\n          finished();\n        } else {\n          this.once('finish', finished);\n        }\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.metadata(this.options, (err, metadata) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(metadata);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Access to pixel-derived image statistics for every channel in the image.\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `channels`: Array of channel statistics for each channel in the image. Each channel statistic contains\n *     - `min` (minimum value in the channel)\n *     - `max` (maximum value in the channel)\n *     - `sum` (sum of all values in a channel)\n *     - `squaresSum` (sum of squared values in a channel)\n *     - `mean` (mean of the values in a channel)\n *     - `stdev` (standard deviation for the values in a channel)\n *     - `minX` (x-coordinate of one of the pixel where the minimum lies)\n *     - `minY` (y-coordinate of one of the pixel where the minimum lies)\n *     - `maxX` (x-coordinate of one of the pixel where the maximum lies)\n *     - `maxY` (y-coordinate of one of the pixel where the maximum lies)\n * - `isOpaque`: Is the image fully opaque? Will be `true` if the image has no alpha channel or if every pixel is fully opaque.\n * - `entropy`: Histogram-based estimation of greyscale entropy, discarding alpha channel if any.\n * - `sharpness`: Estimation of greyscale sharpness based on the standard deviation of a Laplacian convolution, discarding alpha channel if any.\n * - `dominant`: Object containing most dominant sRGB colour based on a 4096-bin 3D histogram.\n *\n * **Note**: Statistics are derived from the original input image. Any operations performed on the image must first be\n * written to a buffer in order to run `stats` on the result (see third example).\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .stats()\n *   .then(function(stats) {\n *      // stats contains the channel-wise statistics array and the isOpaque value\n *   });\n *\n * @example\n * const { entropy, sharpness, dominant } = await sharp(input).stats();\n * const { r, g, b } = dominant;\n *\n * @example\n * const image = sharp(input);\n * // store intermediate result\n * const part = await image.extract(region).toBuffer();\n * // create new instance to obtain statistics of extracted region\n * const stats = await sharp(part).stats();\n *\n * @param {Function} [callback] - called with the arguments `(err, stats)`\n * @returns {Promise<Object>}\n */\nfunction stats(callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.stats(this.options, callback);\n      });\n    } else {\n      sharp.stats(this.options, callback);\n    }\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        this.on('finish', function () {\n          this._flattenBufferIn();\n          sharp.stats(this.options, (err, stats) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(stats);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.stats(this.options, (err, stats) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(stats);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with input-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Private\n    _inputOptionsFromObject,\n    _createInputDescriptor,\n    _write,\n    _flattenBufferIn,\n    _isStreamInput,\n    // Public\n    metadata,\n    stats\n  });\n  // Class attributes\n  Sharp.align = align;\n};","map":{"version":3,"names":["color","require","is","sharp","align","left","center","centre","right","_inputOptionsFromObject","obj","raw","density","limitInputPixels","ignoreIcc","unlimited","sequentialRead","failOn","failOnError","animated","page","pages","subifd","some","defined","undefined","_createInputDescriptor","input","inputOptions","containerOptions","inputDescriptor","Math","pow","string","file","buffer","length","Error","arrayBuffer","byteLength","Buffer","from","typedArray","byteOffset","plainObject","object","allowStream","bool","invalidParameterError","inArray","inRange","integer","Number","MAX_SAFE_INTEGER","width","height","channels","rawWidth","rawHeight","rawChannels","rawPremultiplied","premultiplied","constructor","Uint8Array","Uint8ClampedArray","rawDepth","Int8Array","Uint16Array","Int16Array","Uint32Array","Int32Array","Float32Array","Float64Array","level","create","createWidth","createHeight","createChannels","noise","type","createNoiseType","number","mean","createNoiseMean","sigma","createNoiseSigma","background","createBackground","red","green","blue","round","alpha","text","textValue","dpi","font","textFont","fontfile","textFontfile","textWidth","textHeight","textAlign","justify","textJustify","textDpi","rgba","textRgba","spacing","textSpacing","wrap","textWrap","_write","chunk","encoding","callback","Array","isArray","options","on","streamInFinished","push","_flattenBufferIn","_isStreamInput","concat","metadata","fn","Promise","resolve","reject","finished","err","writableFinished","once","stats","module","exports","Sharp","Object","assign","prototype"],"sources":["/Users/divyakulkarni/Desktop/IAMW/image-annotation-measurement/node_modules/sharp/lib/input.js"],"sourcesContent":["// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst color = require('color');\nconst is = require('./is');\nconst sharp = require('./sharp');\n\n/**\n * Justication alignment\n * @member\n * @private\n */\nconst align = {\n  left: 'low',\n  center: 'centre',\n  centre: 'centre',\n  right: 'high'\n};\n\n/**\n * Extract input options, if any, from an object.\n * @private\n */\nfunction _inputOptionsFromObject (obj) {\n  const { raw, density, limitInputPixels, ignoreIcc, unlimited, sequentialRead, failOn, failOnError, animated, page, pages, subifd } = obj;\n  return [raw, density, limitInputPixels, ignoreIcc, unlimited, sequentialRead, failOn, failOnError, animated, page, pages, subifd].some(is.defined)\n    ? { raw, density, limitInputPixels, ignoreIcc, unlimited, sequentialRead, failOn, failOnError, animated, page, pages, subifd }\n    : undefined;\n}\n\n/**\n * Create Object containing input and input-related options.\n * @private\n */\nfunction _createInputDescriptor (input, inputOptions, containerOptions) {\n  const inputDescriptor = {\n    failOn: 'warning',\n    limitInputPixels: Math.pow(0x3FFF, 2),\n    ignoreIcc: false,\n    unlimited: false,\n    sequentialRead: true\n  };\n  if (is.string(input)) {\n    // filesystem\n    inputDescriptor.file = input;\n  } else if (is.buffer(input)) {\n    // Buffer\n    if (input.length === 0) {\n      throw Error('Input Buffer is empty');\n    }\n    inputDescriptor.buffer = input;\n  } else if (is.arrayBuffer(input)) {\n    if (input.byteLength === 0) {\n      throw Error('Input bit Array is empty');\n    }\n    inputDescriptor.buffer = Buffer.from(input, 0, input.byteLength);\n  } else if (is.typedArray(input)) {\n    if (input.length === 0) {\n      throw Error('Input Bit Array is empty');\n    }\n    inputDescriptor.buffer = Buffer.from(input.buffer, input.byteOffset, input.byteLength);\n  } else if (is.plainObject(input) && !is.defined(inputOptions)) {\n    // Plain Object descriptor, e.g. create\n    inputOptions = input;\n    if (_inputOptionsFromObject(inputOptions)) {\n      // Stream with options\n      inputDescriptor.buffer = [];\n    }\n  } else if (!is.defined(input) && !is.defined(inputOptions) && is.object(containerOptions) && containerOptions.allowStream) {\n    // Stream without options\n    inputDescriptor.buffer = [];\n  } else {\n    throw new Error(`Unsupported input '${input}' of type ${typeof input}${\n      is.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ''\n    }`);\n  }\n  if (is.object(inputOptions)) {\n    // Deprecated: failOnError\n    if (is.defined(inputOptions.failOnError)) {\n      if (is.bool(inputOptions.failOnError)) {\n        inputDescriptor.failOn = inputOptions.failOnError ? 'warning' : 'none';\n      } else {\n        throw is.invalidParameterError('failOnError', 'boolean', inputOptions.failOnError);\n      }\n    }\n    // failOn\n    if (is.defined(inputOptions.failOn)) {\n      if (is.string(inputOptions.failOn) && is.inArray(inputOptions.failOn, ['none', 'truncated', 'error', 'warning'])) {\n        inputDescriptor.failOn = inputOptions.failOn;\n      } else {\n        throw is.invalidParameterError('failOn', 'one of: none, truncated, error, warning', inputOptions.failOn);\n      }\n    }\n    // Density\n    if (is.defined(inputOptions.density)) {\n      if (is.inRange(inputOptions.density, 1, 100000)) {\n        inputDescriptor.density = inputOptions.density;\n      } else {\n        throw is.invalidParameterError('density', 'number between 1 and 100000', inputOptions.density);\n      }\n    }\n    // Ignore embeddded ICC profile\n    if (is.defined(inputOptions.ignoreIcc)) {\n      if (is.bool(inputOptions.ignoreIcc)) {\n        inputDescriptor.ignoreIcc = inputOptions.ignoreIcc;\n      } else {\n        throw is.invalidParameterError('ignoreIcc', 'boolean', inputOptions.ignoreIcc);\n      }\n    }\n    // limitInputPixels\n    if (is.defined(inputOptions.limitInputPixels)) {\n      if (is.bool(inputOptions.limitInputPixels)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels\n          ? Math.pow(0x3FFF, 2)\n          : 0;\n      } else if (is.integer(inputOptions.limitInputPixels) && is.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {\n        inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;\n      } else {\n        throw is.invalidParameterError('limitInputPixels', 'positive integer', inputOptions.limitInputPixels);\n      }\n    }\n    // unlimited\n    if (is.defined(inputOptions.unlimited)) {\n      if (is.bool(inputOptions.unlimited)) {\n        inputDescriptor.unlimited = inputOptions.unlimited;\n      } else {\n        throw is.invalidParameterError('unlimited', 'boolean', inputOptions.unlimited);\n      }\n    }\n    // sequentialRead\n    if (is.defined(inputOptions.sequentialRead)) {\n      if (is.bool(inputOptions.sequentialRead)) {\n        inputDescriptor.sequentialRead = inputOptions.sequentialRead;\n      } else {\n        throw is.invalidParameterError('sequentialRead', 'boolean', inputOptions.sequentialRead);\n      }\n    }\n    // Raw pixel input\n    if (is.defined(inputOptions.raw)) {\n      if (\n        is.object(inputOptions.raw) &&\n        is.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 &&\n        is.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 &&\n        is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)\n      ) {\n        inputDescriptor.rawWidth = inputOptions.raw.width;\n        inputDescriptor.rawHeight = inputOptions.raw.height;\n        inputDescriptor.rawChannels = inputOptions.raw.channels;\n        inputDescriptor.rawPremultiplied = !!inputOptions.raw.premultiplied;\n\n        switch (input.constructor) {\n          case Uint8Array:\n          case Uint8ClampedArray:\n            inputDescriptor.rawDepth = 'uchar';\n            break;\n          case Int8Array:\n            inputDescriptor.rawDepth = 'char';\n            break;\n          case Uint16Array:\n            inputDescriptor.rawDepth = 'ushort';\n            break;\n          case Int16Array:\n            inputDescriptor.rawDepth = 'short';\n            break;\n          case Uint32Array:\n            inputDescriptor.rawDepth = 'uint';\n            break;\n          case Int32Array:\n            inputDescriptor.rawDepth = 'int';\n            break;\n          case Float32Array:\n            inputDescriptor.rawDepth = 'float';\n            break;\n          case Float64Array:\n            inputDescriptor.rawDepth = 'double';\n            break;\n          default:\n            inputDescriptor.rawDepth = 'uchar';\n            break;\n        }\n      } else {\n        throw new Error('Expected width, height and channels for raw pixel input');\n      }\n    }\n    // Multi-page input (GIF, TIFF, PDF)\n    if (is.defined(inputOptions.animated)) {\n      if (is.bool(inputOptions.animated)) {\n        inputDescriptor.pages = inputOptions.animated ? -1 : 1;\n      } else {\n        throw is.invalidParameterError('animated', 'boolean', inputOptions.animated);\n      }\n    }\n    if (is.defined(inputOptions.pages)) {\n      if (is.integer(inputOptions.pages) && is.inRange(inputOptions.pages, -1, 100000)) {\n        inputDescriptor.pages = inputOptions.pages;\n      } else {\n        throw is.invalidParameterError('pages', 'integer between -1 and 100000', inputOptions.pages);\n      }\n    }\n    if (is.defined(inputOptions.page)) {\n      if (is.integer(inputOptions.page) && is.inRange(inputOptions.page, 0, 100000)) {\n        inputDescriptor.page = inputOptions.page;\n      } else {\n        throw is.invalidParameterError('page', 'integer between 0 and 100000', inputOptions.page);\n      }\n    }\n    // Multi-level input (OpenSlide)\n    if (is.defined(inputOptions.level)) {\n      if (is.integer(inputOptions.level) && is.inRange(inputOptions.level, 0, 256)) {\n        inputDescriptor.level = inputOptions.level;\n      } else {\n        throw is.invalidParameterError('level', 'integer between 0 and 256', inputOptions.level);\n      }\n    }\n    // Sub Image File Directory (TIFF)\n    if (is.defined(inputOptions.subifd)) {\n      if (is.integer(inputOptions.subifd) && is.inRange(inputOptions.subifd, -1, 100000)) {\n        inputDescriptor.subifd = inputOptions.subifd;\n      } else {\n        throw is.invalidParameterError('subifd', 'integer between -1 and 100000', inputOptions.subifd);\n      }\n    }\n    // Create new image\n    if (is.defined(inputOptions.create)) {\n      if (\n        is.object(inputOptions.create) &&\n        is.integer(inputOptions.create.width) && inputOptions.create.width > 0 &&\n        is.integer(inputOptions.create.height) && inputOptions.create.height > 0 &&\n        is.integer(inputOptions.create.channels)\n      ) {\n        inputDescriptor.createWidth = inputOptions.create.width;\n        inputDescriptor.createHeight = inputOptions.create.height;\n        inputDescriptor.createChannels = inputOptions.create.channels;\n        // Noise\n        if (is.defined(inputOptions.create.noise)) {\n          if (!is.object(inputOptions.create.noise)) {\n            throw new Error('Expected noise to be an object');\n          }\n          if (!is.inArray(inputOptions.create.noise.type, ['gaussian'])) {\n            throw new Error('Only gaussian noise is supported at the moment');\n          }\n          if (!is.inRange(inputOptions.create.channels, 1, 4)) {\n            throw is.invalidParameterError('create.channels', 'number between 1 and 4', inputOptions.create.channels);\n          }\n          inputDescriptor.createNoiseType = inputOptions.create.noise.type;\n          if (is.number(inputOptions.create.noise.mean) && is.inRange(inputOptions.create.noise.mean, 0, 10000)) {\n            inputDescriptor.createNoiseMean = inputOptions.create.noise.mean;\n          } else {\n            throw is.invalidParameterError('create.noise.mean', 'number between 0 and 10000', inputOptions.create.noise.mean);\n          }\n          if (is.number(inputOptions.create.noise.sigma) && is.inRange(inputOptions.create.noise.sigma, 0, 10000)) {\n            inputDescriptor.createNoiseSigma = inputOptions.create.noise.sigma;\n          } else {\n            throw is.invalidParameterError('create.noise.sigma', 'number between 0 and 10000', inputOptions.create.noise.sigma);\n          }\n        } else if (is.defined(inputOptions.create.background)) {\n          if (!is.inRange(inputOptions.create.channels, 3, 4)) {\n            throw is.invalidParameterError('create.channels', 'number between 3 and 4', inputOptions.create.channels);\n          }\n          const background = color(inputOptions.create.background);\n          inputDescriptor.createBackground = [\n            background.red(),\n            background.green(),\n            background.blue(),\n            Math.round(background.alpha() * 255)\n          ];\n        } else {\n          throw new Error('Expected valid noise or background to create a new input image');\n        }\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected valid width, height and channels to create a new input image');\n      }\n    }\n    // Create a new image with text\n    if (is.defined(inputOptions.text)) {\n      if (is.object(inputOptions.text) && is.string(inputOptions.text.text)) {\n        inputDescriptor.textValue = inputOptions.text.text;\n        if (is.defined(inputOptions.text.height) && is.defined(inputOptions.text.dpi)) {\n          throw new Error('Expected only one of dpi or height');\n        }\n        if (is.defined(inputOptions.text.font)) {\n          if (is.string(inputOptions.text.font)) {\n            inputDescriptor.textFont = inputOptions.text.font;\n          } else {\n            throw is.invalidParameterError('text.font', 'string', inputOptions.text.font);\n          }\n        }\n        if (is.defined(inputOptions.text.fontfile)) {\n          if (is.string(inputOptions.text.fontfile)) {\n            inputDescriptor.textFontfile = inputOptions.text.fontfile;\n          } else {\n            throw is.invalidParameterError('text.fontfile', 'string', inputOptions.text.fontfile);\n          }\n        }\n        if (is.defined(inputOptions.text.width)) {\n          if (is.number(inputOptions.text.width)) {\n            inputDescriptor.textWidth = inputOptions.text.width;\n          } else {\n            throw is.invalidParameterError('text.textWidth', 'number', inputOptions.text.width);\n          }\n        }\n        if (is.defined(inputOptions.text.height)) {\n          if (is.number(inputOptions.text.height)) {\n            inputDescriptor.textHeight = inputOptions.text.height;\n          } else {\n            throw is.invalidParameterError('text.height', 'number', inputOptions.text.height);\n          }\n        }\n        if (is.defined(inputOptions.text.align)) {\n          if (is.string(inputOptions.text.align) && is.string(this.constructor.align[inputOptions.text.align])) {\n            inputDescriptor.textAlign = this.constructor.align[inputOptions.text.align];\n          } else {\n            throw is.invalidParameterError('text.align', 'valid alignment', inputOptions.text.align);\n          }\n        }\n        if (is.defined(inputOptions.text.justify)) {\n          if (is.bool(inputOptions.text.justify)) {\n            inputDescriptor.textJustify = inputOptions.text.justify;\n          } else {\n            throw is.invalidParameterError('text.justify', 'boolean', inputOptions.text.justify);\n          }\n        }\n        if (is.defined(inputOptions.text.dpi)) {\n          if (is.number(inputOptions.text.dpi) && is.inRange(inputOptions.text.dpi, 1, 100000)) {\n            inputDescriptor.textDpi = inputOptions.text.dpi;\n          } else {\n            throw is.invalidParameterError('text.dpi', 'number between 1 and 100000', inputOptions.text.dpi);\n          }\n        }\n        if (is.defined(inputOptions.text.rgba)) {\n          if (is.bool(inputOptions.text.rgba)) {\n            inputDescriptor.textRgba = inputOptions.text.rgba;\n          } else {\n            throw is.invalidParameterError('text.rgba', 'bool', inputOptions.text.rgba);\n          }\n        }\n        if (is.defined(inputOptions.text.spacing)) {\n          if (is.number(inputOptions.text.spacing)) {\n            inputDescriptor.textSpacing = inputOptions.text.spacing;\n          } else {\n            throw is.invalidParameterError('text.spacing', 'number', inputOptions.text.spacing);\n          }\n        }\n        if (is.defined(inputOptions.text.wrap)) {\n          if (is.string(inputOptions.text.wrap) && is.inArray(inputOptions.text.wrap, ['word', 'char', 'wordChar', 'none'])) {\n            inputDescriptor.textWrap = inputOptions.text.wrap;\n          } else {\n            throw is.invalidParameterError('text.wrap', 'one of: word, char, wordChar, none', inputOptions.text.wrap);\n          }\n        }\n        delete inputDescriptor.buffer;\n      } else {\n        throw new Error('Expected a valid string to create an image with text.');\n      }\n    }\n  } else if (is.defined(inputOptions)) {\n    throw new Error('Invalid input options ' + inputOptions);\n  }\n  return inputDescriptor;\n}\n\n/**\n * Handle incoming Buffer chunk on Writable Stream.\n * @private\n * @param {Buffer} chunk\n * @param {string} encoding - unused\n * @param {Function} callback\n */\nfunction _write (chunk, encoding, callback) {\n  /* istanbul ignore else */\n  if (Array.isArray(this.options.input.buffer)) {\n    /* istanbul ignore else */\n    if (is.buffer(chunk)) {\n      if (this.options.input.buffer.length === 0) {\n        this.on('finish', () => {\n          this.streamInFinished = true;\n        });\n      }\n      this.options.input.buffer.push(chunk);\n      callback();\n    } else {\n      callback(new Error('Non-Buffer data on Writable Stream'));\n    }\n  } else {\n    callback(new Error('Unexpected data on Writable Stream'));\n  }\n}\n\n/**\n * Flattens the array of chunks accumulated in input.buffer.\n * @private\n */\nfunction _flattenBufferIn () {\n  if (this._isStreamInput()) {\n    this.options.input.buffer = Buffer.concat(this.options.input.buffer);\n  }\n}\n\n/**\n * Are we expecting Stream-based input?\n * @private\n * @returns {boolean}\n */\nfunction _isStreamInput () {\n  return Array.isArray(this.options.input.buffer);\n}\n\n/**\n * Fast access to (uncached) image metadata without decoding any compressed pixel data.\n *\n * This is read from the header of the input image.\n * It does not take into consideration any operations to be applied to the output image,\n * such as resize or rotate.\n *\n * Dimensions in the response will respect the `page` and `pages` properties of the\n * {@link /api-constructor#parameters|constructor parameters}.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `format`: Name of decoder used to decompress image data e.g. `jpeg`, `png`, `webp`, `gif`, `svg`\n * - `size`: Total size of image in bytes, for Stream and Buffer input only\n * - `width`: Number of pixels wide (EXIF orientation is not taken into consideration, see example below)\n * - `height`: Number of pixels high (EXIF orientation is not taken into consideration, see example below)\n * - `space`: Name of colour space interpretation e.g. `srgb`, `rgb`, `cmyk`, `lab`, `b-w` [...](https://www.libvips.org/API/current/VipsImage.html#VipsInterpretation)\n * - `channels`: Number of bands e.g. `3` for sRGB, `4` for CMYK\n * - `depth`: Name of pixel depth format e.g. `uchar`, `char`, `ushort`, `float` [...](https://www.libvips.org/API/current/VipsImage.html#VipsBandFormat)\n * - `density`: Number of pixels per inch (DPI), if present\n * - `chromaSubsampling`: String containing JPEG chroma subsampling, `4:2:0` or `4:4:4` for RGB, `4:2:0:4` or `4:4:4:4` for CMYK\n * - `isProgressive`: Boolean indicating whether the image is interlaced using a progressive scan\n * - `pages`: Number of pages/frames contained within the image, with support for TIFF, HEIF, PDF, animated GIF and animated WebP\n * - `pageHeight`: Number of pixels high each page in a multi-page image will be.\n * - `loop`: Number of times to loop an animated image, zero refers to a continuous loop.\n * - `delay`: Delay in ms between each page in an animated image, provided as an array of integers.\n * - `pagePrimary`: Number of the primary page in a HEIF image\n * - `levels`: Details of each level in a multi-level image provided as an array of objects, requires libvips compiled with support for OpenSlide\n * - `subifds`: Number of Sub Image File Directories in an OME-TIFF image\n * - `background`: Default background colour, if present, for PNG (bKGD) and GIF images, either an RGB Object or a single greyscale value\n * - `compression`: The encoder used to compress an HEIF file, `av1` (AVIF) or `hevc` (HEIC)\n * - `resolutionUnit`: The unit of resolution (density), either `inch` or `cm`, if present\n * - `hasProfile`: Boolean indicating the presence of an embedded ICC profile\n * - `hasAlpha`: Boolean indicating the presence of an alpha transparency channel\n * - `orientation`: Number value of the EXIF Orientation header, if present\n * - `exif`: Buffer containing raw EXIF data, if present\n * - `icc`: Buffer containing raw [ICC](https://www.npmjs.com/package/icc) profile data, if present\n * - `iptc`: Buffer containing raw IPTC data, if present\n * - `xmp`: Buffer containing raw XMP data, if present\n * - `tifftagPhotoshop`: Buffer containing raw TIFFTAG_PHOTOSHOP data, if present\n * - `formatMagick`: String containing format for images loaded via *magick\n *\n * @example\n * const metadata = await sharp(input).metadata();\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .metadata()\n *   .then(function(metadata) {\n *     return image\n *       .resize(Math.round(metadata.width / 2))\n *       .webp()\n *       .toBuffer();\n *   })\n *   .then(function(data) {\n *     // data contains a WebP image half the width and height of the original JPEG\n *   });\n *\n * @example\n * // Based on EXIF rotation metadata, get the right-side-up width and height:\n *\n * const size = getNormalSize(await sharp(input).metadata());\n *\n * function getNormalSize({ width, height, orientation }) {\n *   return (orientation || 0) >= 5\n *     ? { width: height, height: width }\n *     : { width, height };\n * }\n *\n * @param {Function} [callback] - called with the arguments `(err, metadata)`\n * @returns {Promise<Object>|Sharp}\n */\nfunction metadata (callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.metadata(this.options, callback);\n      });\n    } else {\n      sharp.metadata(this.options, callback);\n    }\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        const finished = () => {\n          this._flattenBufferIn();\n          sharp.metadata(this.options, (err, metadata) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(metadata);\n            }\n          });\n        };\n        if (this.writableFinished) {\n          finished();\n        } else {\n          this.once('finish', finished);\n        }\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.metadata(this.options, (err, metadata) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(metadata);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Access to pixel-derived image statistics for every channel in the image.\n * A `Promise` is returned when `callback` is not provided.\n *\n * - `channels`: Array of channel statistics for each channel in the image. Each channel statistic contains\n *     - `min` (minimum value in the channel)\n *     - `max` (maximum value in the channel)\n *     - `sum` (sum of all values in a channel)\n *     - `squaresSum` (sum of squared values in a channel)\n *     - `mean` (mean of the values in a channel)\n *     - `stdev` (standard deviation for the values in a channel)\n *     - `minX` (x-coordinate of one of the pixel where the minimum lies)\n *     - `minY` (y-coordinate of one of the pixel where the minimum lies)\n *     - `maxX` (x-coordinate of one of the pixel where the maximum lies)\n *     - `maxY` (y-coordinate of one of the pixel where the maximum lies)\n * - `isOpaque`: Is the image fully opaque? Will be `true` if the image has no alpha channel or if every pixel is fully opaque.\n * - `entropy`: Histogram-based estimation of greyscale entropy, discarding alpha channel if any.\n * - `sharpness`: Estimation of greyscale sharpness based on the standard deviation of a Laplacian convolution, discarding alpha channel if any.\n * - `dominant`: Object containing most dominant sRGB colour based on a 4096-bin 3D histogram.\n *\n * **Note**: Statistics are derived from the original input image. Any operations performed on the image must first be\n * written to a buffer in order to run `stats` on the result (see third example).\n *\n * @example\n * const image = sharp(inputJpg);\n * image\n *   .stats()\n *   .then(function(stats) {\n *      // stats contains the channel-wise statistics array and the isOpaque value\n *   });\n *\n * @example\n * const { entropy, sharpness, dominant } = await sharp(input).stats();\n * const { r, g, b } = dominant;\n *\n * @example\n * const image = sharp(input);\n * // store intermediate result\n * const part = await image.extract(region).toBuffer();\n * // create new instance to obtain statistics of extracted region\n * const stats = await sharp(part).stats();\n *\n * @param {Function} [callback] - called with the arguments `(err, stats)`\n * @returns {Promise<Object>}\n */\nfunction stats (callback) {\n  if (is.fn(callback)) {\n    if (this._isStreamInput()) {\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.stats(this.options, callback);\n      });\n    } else {\n      sharp.stats(this.options, callback);\n    }\n    return this;\n  } else {\n    if (this._isStreamInput()) {\n      return new Promise((resolve, reject) => {\n        this.on('finish', function () {\n          this._flattenBufferIn();\n          sharp.stats(this.options, (err, stats) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(stats);\n            }\n          });\n        });\n      });\n    } else {\n      return new Promise((resolve, reject) => {\n        sharp.stats(this.options, (err, stats) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(stats);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with input-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Private\n    _inputOptionsFromObject,\n    _createInputDescriptor,\n    _write,\n    _flattenBufferIn,\n    _isStreamInput,\n    // Public\n    metadata,\n    stats\n  });\n  // Class attributes\n  Sharp.align = align;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}