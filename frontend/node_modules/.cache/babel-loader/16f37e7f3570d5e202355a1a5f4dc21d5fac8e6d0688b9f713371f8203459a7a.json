{"ast":null,"code":"// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst path = require('path');\nconst is = require('./is');\nconst sharp = require('./sharp');\nconst formats = new Map([['heic', 'heif'], ['heif', 'heif'], ['avif', 'avif'], ['jpeg', 'jpeg'], ['jpg', 'jpeg'], ['jpe', 'jpeg'], ['tile', 'tile'], ['dz', 'tile'], ['png', 'png'], ['raw', 'raw'], ['tiff', 'tiff'], ['tif', 'tiff'], ['webp', 'webp'], ['gif', 'gif'], ['jp2', 'jp2'], ['jpx', 'jp2'], ['j2k', 'jp2'], ['j2c', 'jp2'], ['jxl', 'jxl']]);\nconst jp2Regex = /\\.jp[2x]|j2[kc]$/i;\nconst errJp2Save = () => new Error('JP2 output requires libvips with support for OpenJPEG');\nconst bitdepthFromColourCount = colours => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));\n\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, AVIF, TIFF, GIF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * The caller is responsible for ensuring directory structures and permissions exist.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toFile('output.png', (err, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toFile('output.png')\n *   .then(info => { ... })\n *   .catch(err => { ... });\n *\n * @param {string} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * When using the attention crop strategy also contains `attentionX` and `attentionY`, the focal point of the cropped region.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\nfunction toFile(fileOut, callback) {\n  let err;\n  if (!is.string(fileOut)) {\n    err = new Error('Missing output file path');\n  } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {\n    err = new Error('Cannot use same file for input and output');\n  } else if (jp2Regex.test(fileOut) && !this.constructor.format.jp2k.output.file) {\n    err = errJp2Save();\n  }\n  if (err) {\n    if (is.fn(callback)) {\n      callback(err);\n    } else {\n      return Promise.reject(err);\n    }\n  } else {\n    this.options.fileOut = fileOut;\n    return this._pipeline(callback);\n  }\n  return this;\n}\n\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, AVIF, TIFF, GIF and raw pixel data output are supported.\n *\n * Use {@link #toformat|toFormat} or one of the format-specific functions such as {@link jpeg}, {@link png} etc. to set the output format.\n *\n * If no explicit format is set, the output format will match the input image, except SVG input which becomes PNG output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toBuffer((err, data, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer()\n *   .then(data => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * sharp(input)\n *   .png()\n *   .toBuffer({ resolveWithObject: true })\n *   .then(({ data, info }) => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * const { data, info } = await sharp('my-image.jpg')\n *   // output the raw pixels\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * // create a more type safe way to work with the raw pixel data\n * // this will not copy the data, instead it will change `data`s underlying ArrayBuffer\n * // so `data` and `pixelArray` point to the same memory location\n * const pixelArray = new Uint8ClampedArray(data.buffer);\n *\n * // When you are done changing the pixelArray, sharp takes the `pixelArray` as an input\n * const { width, height, channels } = info;\n * await sharp(pixelArray, { raw: { width, height, channels } })\n *   .toFile('my-changed-image.jpg');\n *\n * @param {Object} [options]\n * @param {boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\nfunction toBuffer(options, callback) {\n  if (is.object(options)) {\n    this._setBooleanOption('resolveWithObject', options.resolveWithObject);\n  } else if (this.options.resolveWithObject) {\n    this.options.resolveWithObject = false;\n  }\n  this.options.fileOut = '';\n  return this._pipeline(is.fn(options) ? options : callback);\n}\n\n/**\n * Include all metadata (EXIF, XMP, IPTC) from the input image in the output image.\n * This will also convert to and add a web-friendly sRGB ICC profile unless a custom\n * output profile is provided.\n *\n * The default behaviour, when `withMetadata` is not used, is to convert to the device-independent\n * sRGB colour space and strip all metadata, including the removal of any ICC profile.\n *\n * EXIF metadata is unsupported for TIFF output.\n *\n * @example\n * sharp('input.jpg')\n *   .withMetadata()\n *   .toFile('output-with-metadata.jpg')\n *   .then(info => { ... });\n *\n * @example\n * // Set output EXIF metadata\n * const data = await sharp(input)\n *   .withMetadata({\n *     exif: {\n *       IFD0: {\n *         Copyright: 'The National Gallery'\n *       },\n *       IFD3: {\n *         GPSLatitudeRef: 'N',\n *         GPSLatitude: '51/1 30/1 3230/100',\n *         GPSLongitudeRef: 'W',\n *         GPSLongitude: '0/1 7/1 4366/100'\n *       }\n *     }\n *   })\n *   .toBuffer();\n *\n * @example\n * // Set output metadata to 96 DPI\n * const data = await sharp(input)\n *   .withMetadata({ density: 96 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.orientation] value between 1 and 8, used to update the EXIF `Orientation` tag.\n * @param {string} [options.icc='srgb'] Filesystem path to output ICC profile, relative to `process.cwd()`, defaults to built-in sRGB.\n * @param {Object<Object>} [options.exif={}] Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @param {number} [options.density] Number of pixels per inch (DPI).\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withMetadata(options) {\n  this.options.withMetadata = is.bool(options) ? options : true;\n  if (is.object(options)) {\n    if (is.defined(options.orientation)) {\n      if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = options.orientation;\n      } else {\n        throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);\n      }\n    }\n    if (is.defined(options.density)) {\n      if (is.number(options.density) && options.density > 0) {\n        this.options.withMetadataDensity = options.density;\n      } else {\n        throw is.invalidParameterError('density', 'positive number', options.density);\n      }\n    }\n    if (is.defined(options.icc)) {\n      if (is.string(options.icc)) {\n        this.options.withMetadataIcc = options.icc;\n      } else {\n        throw is.invalidParameterError('icc', 'string filesystem path to ICC profile', options.icc);\n      }\n    }\n    if (is.defined(options.exif)) {\n      if (is.object(options.exif)) {\n        for (const [ifd, entries] of Object.entries(options.exif)) {\n          if (is.object(entries)) {\n            for (const [k, v] of Object.entries(entries)) {\n              if (is.string(v)) {\n                this.options.withMetadataStrs[`exif-${ifd.toLowerCase()}-${k}`] = v;\n              } else {\n                throw is.invalidParameterError(`exif.${ifd}.${k}`, 'string', v);\n              }\n            }\n          } else {\n            throw is.invalidParameterError(`exif.${ifd}`, 'object', entries);\n          }\n        }\n      } else {\n        throw is.invalidParameterError('exif', 'object', options.exif);\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Force output to a given format.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .toFormat('png')\n *   .toBuffer();\n *\n * @param {(string|Object)} format - as a string or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\nfunction toFormat(format, options) {\n  const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());\n  if (!actualFormat) {\n    throw is.invalidParameterError('format', `one of: ${[...formats.keys()].join(', ')}`, format);\n  }\n  return this[actualFormat](options);\n}\n\n/**\n * Use these JPEG options for output image.\n *\n * @example\n * // Convert any input to very high quality JPEG output\n * const data = await sharp(input)\n *   .jpeg({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @example\n * // Use mozjpeg to reduce output JPEG file size (slower)\n * const data = await sharp(input)\n *   .jpeg({ mozjpeg: true })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {string} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling otherwise defaults to '4:2:0' chroma subsampling\n * @param {boolean} [options.optimiseCoding=true] - optimise Huffman coding tables\n * @param {boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding\n * @param {boolean} [options.mozjpeg=false] - use mozjpeg defaults, equivalent to `{ trellisQuantisation: true, overshootDeringing: true, optimiseScans: true, quantisationTable: 3 }`\n * @param {boolean} [options.trellisQuantisation=false] - apply trellis quantisation\n * @param {boolean} [options.overshootDeringing=false] - apply overshoot deringing\n * @param {boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive\n * @param {boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {number} [options.quantisationTable=0] - quantization table to use, integer 0-8\n * @param {number} [options.quantizationTable=0] - alternative spelling of quantisationTable\n * @param {boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jpeg(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;\n    if (is.defined(optimiseCoding)) {\n      this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);\n    }\n    if (is.defined(options.mozjpeg)) {\n      if (is.bool(options.mozjpeg)) {\n        if (options.mozjpeg) {\n          this.options.jpegTrellisQuantisation = true;\n          this.options.jpegOvershootDeringing = true;\n          this.options.jpegOptimiseScans = true;\n          this.options.jpegProgressive = true;\n          this.options.jpegQuantisationTable = 3;\n        }\n      } else {\n        throw is.invalidParameterError('mozjpeg', 'boolean', options.mozjpeg);\n      }\n    }\n    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n    if (is.defined(trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);\n    }\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n    if (is.defined(optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', optimiseScans);\n      if (optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;\n    if (is.defined(quantisationTable)) {\n      if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {\n        this.options.jpegQuantisationTable = quantisationTable;\n      } else {\n        throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);\n      }\n    }\n  }\n  return this._updateFormatOut('jpeg', options);\n}\n\n/**\n * Use these PNG options for output image.\n *\n * By default, PNG output is full colour at 8 or 16 bits per pixel.\n * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.\n * Set `palette` to `true` for slower, indexed PNG output.\n *\n * @example\n * // Convert any input to full colour PNG output\n * const data = await sharp(input)\n *   .png()\n *   .toBuffer();\n *\n * @example\n * // Convert any input to indexed PNG output (slower)\n * const data = await sharp(input)\n *   .png({ palette: true })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.compressionLevel=6] - zlib compression level, 0 (fastest, largest) to 9 (slowest, smallest)\n * @param {boolean} [options.adaptiveFiltering=false] - use adaptive row filtering\n * @param {boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support\n * @param {number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, sets `palette` to `true`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest), sets `palette` to `true`\n * @param {number} [options.colours=256] - maximum number of palette entries, sets `palette` to `true`\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`, sets `palette` to `true`\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, sets `palette` to `true`\n * @param {boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction png(options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);\n      }\n    }\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.pngBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.palette)) {\n      this._setBooleanOption('pngPalette', options.palette);\n    } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {\n      this._setBooleanOption('pngPalette', true);\n    }\n    if (this.options.pngPalette) {\n      if (is.defined(options.quality)) {\n        if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {\n          this.options.pngQuality = options.quality;\n        } else {\n          throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);\n        }\n      }\n      if (is.defined(options.effort)) {\n        if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {\n          this.options.pngEffort = options.effort;\n        } else {\n          throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n        }\n      }\n      if (is.defined(options.dither)) {\n        if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n          this.options.pngDither = options.dither;\n        } else {\n          throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n        }\n      }\n    }\n  }\n  return this._updateFormatOut('png', options);\n}\n\n/**\n * Use these WebP options for output image.\n *\n * @example\n * // Convert any input to lossless WebP output\n * const data = await sharp(input)\n *   .webp({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Optimise the file size of an animated WebP\n * const outputWebp = await sharp(inputWebp, { animated: true })\n *   .webp({ effort: 6 })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {boolean} [options.smartSubsample=false] - use high quality chroma subsampling\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 6 (slowest)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.minSize=false] - prevent use of animation key frames to minimise file size (slow)\n * @param {boolean} [options.mixed=false] - allow mixture of lossy and lossless animation frames (slow)\n * @param {boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction webp(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.webpQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.alphaQuality)) {\n      if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {\n        this.options.webpAlphaQuality = options.alphaQuality;\n      } else {\n        throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      this._setBooleanOption('webpLossless', options.lossless);\n    }\n    if (is.defined(options.nearLossless)) {\n      this._setBooleanOption('webpNearLossless', options.nearLossless);\n    }\n    if (is.defined(options.smartSubsample)) {\n      this._setBooleanOption('webpSmartSubsample', options.smartSubsample);\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 6)) {\n        this.options.webpEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 6', options.effort);\n      }\n    }\n    if (is.defined(options.minSize)) {\n      this._setBooleanOption('webpMinSize', options.minSize);\n    }\n    if (is.defined(options.mixed)) {\n      this._setBooleanOption('webpMixed', options.mixed);\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('webp', options);\n}\n\n/**\n * Use these GIF options for the output image.\n *\n * The first entry in the palette is reserved for transparency.\n *\n * The palette of the input image will be re-used if possible.\n *\n * @since 0.30.0\n *\n * @example\n * // Convert PNG to GIF\n * await sharp(pngBuffer)\n *   .gif()\n *   .toBuffer();\n *\n * @example\n * // Convert animated WebP to animated GIF\n * await sharp('animated.webp', { animated: true })\n *   .toFile('animated.gif');\n *\n * @example\n * // Create a 128x128, cropped, non-dithered, animated thumbnail of an animated GIF\n * const out = await sharp('in.gif', { animated: true })\n *   .resize({ width: 128, height: 128 })\n *   .gif({ dither: 0 })\n *   .toBuffer();\n *\n * @example\n * // Lossy file size reduction of animated GIF\n * await sharp('in.gif', { animated: true })\n *   .gif({ interFrameMaxError: 8 })\n *   .toFile('optim.gif');\n *\n * @param {Object} [options] - output options\n * @param {boolean} [options.reuse=true] - re-use existing palette, otherwise generate new (slow)\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.colours=256] - maximum number of palette entries, including transparency, between 2 and 256\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest)\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most)\n * @param {number} [options.interFrameMaxError=0] - maximum inter-frame error for transparency, between 0 (lossless) and 32\n * @param {number} [options.interPaletteMaxError=3] - maximum inter-palette error for palette reuse, between 0 and 256\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.force=true] - force GIF output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction gif(options) {\n  if (is.object(options)) {\n    if (is.defined(options.reuse)) {\n      this._setBooleanOption('gifReuse', options.reuse);\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('gifProgressive', options.progressive);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.gifBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {\n        this.options.gifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n      }\n    }\n    if (is.defined(options.dither)) {\n      if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n        this.options.gifDither = options.dither;\n      } else {\n        throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n      }\n    }\n    if (is.defined(options.interFrameMaxError)) {\n      if (is.number(options.interFrameMaxError) && is.inRange(options.interFrameMaxError, 0, 32)) {\n        this.options.gifInterFrameMaxError = options.interFrameMaxError;\n      } else {\n        throw is.invalidParameterError('interFrameMaxError', 'number between 0.0 and 32.0', options.interFrameMaxError);\n      }\n    }\n    if (is.defined(options.interPaletteMaxError)) {\n      if (is.number(options.interPaletteMaxError) && is.inRange(options.interPaletteMaxError, 0, 256)) {\n        this.options.gifInterPaletteMaxError = options.interPaletteMaxError;\n      } else {\n        throw is.invalidParameterError('interPaletteMaxError', 'number between 0.0 and 256.0', options.interPaletteMaxError);\n      }\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('gif', options);\n}\n\n/* istanbul ignore next */\n/**\n * Use these JP2 options for output image.\n *\n * Requires libvips compiled with support for OpenJPEG.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n * // Convert any input to lossless JP2 output\n * const data = await sharp(input)\n *   .jp2({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Convert any input to very high quality JP2 output\n * const data = await sharp(input)\n *   .jp2({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @since 0.29.1\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {number} [options.tileWidth=512] - horizontal tile size\n * @param {number} [options.tileHeight=512] - vertical tile size\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jp2(options) {\n  if (!this.constructor.format.jp2k.output.buffer) {\n    throw errJp2Save();\n  }\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jp2Quality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jp2Lossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {\n        this.options.jp2TileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer between 1 and 32768', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {\n        this.options.jp2TileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer between 1 and 32768', options.tileHeight);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jp2ChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('jp2', options);\n}\n\n/**\n * Set animation options if available.\n * @private\n *\n * @param {Object} [source] - output options\n * @param {number} [source.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number[]} [source.delay] - list of delays between animation frames (in milliseconds)\n * @param {Object} [target] - target object for valid options\n * @throws {Error} Invalid options\n */\nfunction trySetAnimationOptions(source, target) {\n  if (is.object(source) && is.defined(source.loop)) {\n    if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {\n      target.loop = source.loop;\n    } else {\n      throw is.invalidParameterError('loop', 'integer between 0 and 65535', source.loop);\n    }\n  }\n  if (is.object(source) && is.defined(source.delay)) {\n    // We allow singular values as well\n    if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {\n      target.delay = [source.delay];\n    } else if (Array.isArray(source.delay) && source.delay.every(is.integer) && source.delay.every(v => is.inRange(v, 0, 65535))) {\n      target.delay = source.delay;\n    } else {\n      throw is.invalidParameterError('delay', 'integer or an array of integers between 0 and 65535', source.delay);\n    }\n  }\n}\n\n/**\n * Use these TIFF options for output image.\n *\n * The `density` can be set in pixels/inch via {@link #withmetadata|withMetadata}\n * instead of providing `xres` and `yres` in pixels/mm.\n *\n * @example\n * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output\n * sharp('input.svg')\n *   .tiff({\n *     compression: 'lzw',\n *     bitdepth: 1\n *   })\n *   .toFile('1-bpp-output.tiff')\n *   .then(info => { ... });\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {string} [options.compression='jpeg'] - compression options: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k\n * @param {string} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float\n * @param {boolean} [options.pyramid=false] - write an image pyramid\n * @param {boolean} [options.tile=false] - write a tiled tiff\n * @param {number} [options.tileWidth=256] - horizontal tile size\n * @param {number} [options.tileHeight=256] - vertical tile size\n * @param {number} [options.xres=1.0] - horizontal resolution in pixels/mm\n * @param {number} [options.yres=1.0] - vertical resolution in pixels/mm\n * @param {string} [options.resolutionUnit='inch'] - resolution unit options: inch, cm\n * @param {number} [options.bitdepth=8] - reduce bitdepth to 1, 2 or 4 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction tiff(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.tiffQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {\n        this.options.tiffBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '1, 2, 4 or 8', options.bitdepth);\n      }\n    }\n    // tiling\n    if (is.defined(options.tile)) {\n      this._setBooleanOption('tiffTile', options.tile);\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && options.tileWidth > 0) {\n        this.options.tiffTileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && options.tileHeight > 0) {\n        this.options.tiffTileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);\n      }\n    }\n    // pyramid\n    if (is.defined(options.pyramid)) {\n      this._setBooleanOption('tiffPyramid', options.pyramid);\n    }\n    // resolution\n    if (is.defined(options.xres)) {\n      if (is.number(options.xres) && options.xres > 0) {\n        this.options.tiffXres = options.xres;\n      } else {\n        throw is.invalidParameterError('xres', 'number greater than zero', options.xres);\n      }\n    }\n    if (is.defined(options.yres)) {\n      if (is.number(options.yres) && options.yres > 0) {\n        this.options.tiffYres = options.yres;\n      } else {\n        throw is.invalidParameterError('yres', 'number greater than zero', options.yres);\n      }\n    }\n    // compression\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['none', 'jpeg', 'deflate', 'packbits', 'ccittfax4', 'lzw', 'webp', 'zstd', 'jp2k'])) {\n        this.options.tiffCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k', options.compression);\n      }\n    }\n    // predictor\n    if (is.defined(options.predictor)) {\n      if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n        this.options.tiffPredictor = options.predictor;\n      } else {\n        throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);\n      }\n    }\n    // resolutionUnit\n    if (is.defined(options.resolutionUnit)) {\n      if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ['inch', 'cm'])) {\n        this.options.tiffResolutionUnit = options.resolutionUnit;\n      } else {\n        throw is.invalidParameterError('resolutionUnit', 'one of: inch, cm', options.resolutionUnit);\n      }\n    }\n  }\n  return this._updateFormatOut('tiff', options);\n}\n\n/**\n * Use these AVIF options for output image.\n *\n * Whilst it is possible to create AVIF images smaller than 16x16 pixels,\n * most web browsers do not display these properly.\n *\n * AVIF image sequences are not supported.\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ effort: 2 })\n *   .toBuffer();\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ lossless: true })\n *   .toBuffer();\n *\n * @since 0.27.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction avif(options) {\n  return this.heif({\n    ...options,\n    compression: 'av1'\n  });\n}\n\n/**\n * Use these HEIF options for output image.\n *\n * Support for patent-encumbered HEIC images using `hevc` compression requires the use of a\n * globally-installed libvips compiled with support for libheif, libde265 and x265.\n *\n * @example\n * const data = await sharp(input)\n *   .heif({ compression: 'hevc' })\n *   .toBuffer();\n *\n * @since 0.23.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {string} [options.compression='av1'] - compression format: av1, hevc\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction heif(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.heifQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.heifLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['av1', 'hevc'])) {\n        this.options.heifCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: av1, hevc', options.compression);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {\n        this.options.heifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 9', options.effort);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.heifChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('heif', options);\n}\n\n/**\n * Use these JPEG-XL (JXL) options for output image.\n *\n * This feature is experimental, please do not use in production systems.\n *\n * Requires libvips compiled with support for libjxl.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * Image metadata (EXIF, XMP) is unsupported.\n *\n * @since 0.31.3\n *\n * @param {Object} [options] - output options\n * @param {number} [options.distance=1.0] - maximum encoding error, between 0 (highest quality) and 15 (lowest quality)\n * @param {number} [options.quality] - calculate `distance` based on JPEG-like quality, between 1 and 100, overrides distance if specified\n * @param {number} [options.decodingTier=0] - target decode speed tier, between 0 (highest quality) and 4 (lowest quality)\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=7] - CPU effort, between 3 (fastest) and 9 (slowest)\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jxl(options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        // https://github.com/libjxl/libjxl/blob/0aeea7f180bafd6893c1db8072dcb67d2aa5b03d/tools/cjxl_main.cc#L640-L644\n        this.options.jxlDistance = options.quality >= 30 ? 0.1 + (100 - options.quality) * 0.09 : 53 / 3000 * options.quality * options.quality - 23 / 20 * options.quality + 25;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    } else if (is.defined(options.distance)) {\n      if (is.number(options.distance) && is.inRange(options.distance, 0, 15)) {\n        this.options.jxlDistance = options.distance;\n      } else {\n        throw is.invalidParameterError('distance', 'number between 0.0 and 15.0', options.distance);\n      }\n    }\n    if (is.defined(options.decodingTier)) {\n      if (is.integer(options.decodingTier) && is.inRange(options.decodingTier, 0, 4)) {\n        this.options.jxlDecodingTier = options.decodingTier;\n      } else {\n        throw is.invalidParameterError('decodingTier', 'integer between 0 and 4', options.decodingTier);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jxlLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 3, 9)) {\n        this.options.jxlEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 3 and 9', options.effort);\n      }\n    }\n  }\n  return this._updateFormatOut('jxl', options);\n}\n\n/**\n * Force output to be raw, uncompressed pixel data.\n * Pixel ordering is left-to-right, top-to-bottom, without padding.\n * Channel ordering will be RGB or RGBA for non-greyscale colourspaces.\n *\n * @example\n * // Extract raw, unsigned 8-bit RGB pixel data from JPEG input\n * const { data, info } = await sharp('input.jpg')\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * @example\n * // Extract alpha channel as raw, unsigned 16-bit pixel data from PNG input\n * const data = await sharp('input.png')\n *   .ensureAlpha()\n *   .extractChannel(3)\n *   .toColourspace('b-w')\n *   .raw({ depth: 'ushort' })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {string} [options.depth='uchar'] - bit depth, one of: char, uchar (default), short, ushort, int, uint, float, complex, double, dpcomplex\n * @throws {Error} Invalid options\n */\nfunction raw(options) {\n  if (is.object(options)) {\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'complex', 'double', 'dpcomplex'])) {\n        this.options.rawDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex', options.depth);\n      }\n    }\n  }\n  return this._updateFormatOut('raw');\n}\n\n/**\n * Use tile-based deep zoom (image pyramid) output.\n *\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * The container will be set to `zip` when the output is a Buffer or Stream, otherwise it will default to `fs`.\n *\n * Requires libvips compiled with support for libgsf.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @example\n * const zipFileWithTiles = await sharp(input)\n *   .tile({ basename: \"tiles\" })\n *   .toBuffer();\n *\n * @example\n * const iiififier = sharp().tile({ layout: \"iiif\" });\n * readableStream\n *   .pipe(iiififier)\n *   .pipe(writeableStream);\n *\n * @param {Object} [options]\n * @param {number} [options.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {number} [options.angle=0] tile angle of rotation, must be a multiple of 90.\n * @param {string|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.\n * @param {string} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.\n * @param {number} [options.skipBlanks=-1] threshold to skip tile generation, a value 0 - 255 for 8-bit images or 0 - 65535 for 16-bit images\n * @param {string} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {string} [options.layout='dz'] filesystem layout, possible values are `dz`, `iiif`, `iiif3`, `zoomify` or `google`.\n * @param {boolean} [options.centre=false] centre image in tile.\n * @param {boolean} [options.center=false] alternative spelling of centre.\n * @param {string} [options.id='https://example.com/iiif'] when `layout` is `iiif`/`iiif3`, sets the `@id`/`id` attribute of `info.json`\n * @param {string} [options.basename] the name of the directory within the zip file when container is `zip`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction tile(options) {\n  if (is.object(options)) {\n    // Size of square tiles, in pixels\n    if (is.defined(options.size)) {\n      if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {\n        this.options.tileSize = options.size;\n      } else {\n        throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);\n      }\n    }\n    // Overlap of tiles, in pixels\n    if (is.defined(options.overlap)) {\n      if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {\n        if (options.overlap > this.options.tileSize) {\n          throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);\n        }\n        this.options.tileOverlap = options.overlap;\n      } else {\n        throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);\n      }\n    }\n    // Container\n    if (is.defined(options.container)) {\n      if (is.string(options.container) && is.inArray(options.container, ['fs', 'zip'])) {\n        this.options.tileContainer = options.container;\n      } else {\n        throw is.invalidParameterError('container', 'one of: fs, zip', options.container);\n      }\n    }\n    // Layout\n    if (is.defined(options.layout)) {\n      if (is.string(options.layout) && is.inArray(options.layout, ['dz', 'google', 'iiif', 'iiif3', 'zoomify'])) {\n        this.options.tileLayout = options.layout;\n      } else {\n        throw is.invalidParameterError('layout', 'one of: dz, google, iiif, iiif3, zoomify', options.layout);\n      }\n    }\n    // Angle of rotation,\n    if (is.defined(options.angle)) {\n      if (is.integer(options.angle) && !(options.angle % 90)) {\n        this.options.tileAngle = options.angle;\n      } else {\n        throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);\n      }\n    }\n    // Background colour\n    this._setBackgroundColourOption('tileBackground', options.background);\n    // Depth of tiles\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['onepixel', 'onetile', 'one'])) {\n        this.options.tileDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);\n      }\n    }\n    // Threshold to skip blank tiles\n    if (is.defined(options.skipBlanks)) {\n      if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {\n        this.options.tileSkipBlanks = options.skipBlanks;\n      } else {\n        throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);\n      }\n    } else if (is.defined(options.layout) && options.layout === 'google') {\n      this.options.tileSkipBlanks = 5;\n    }\n    // Center image in tile\n    const centre = is.bool(options.center) ? options.center : options.centre;\n    if (is.defined(centre)) {\n      this._setBooleanOption('tileCentre', centre);\n    }\n    // @id attribute for IIIF layout\n    if (is.defined(options.id)) {\n      if (is.string(options.id)) {\n        this.options.tileId = options.id;\n      } else {\n        throw is.invalidParameterError('id', 'string', options.id);\n      }\n    }\n    // Basename for zip container\n    if (is.defined(options.basename)) {\n      if (is.string(options.basename)) {\n        this.options.tileBasename = options.basename;\n      } else {\n        throw is.invalidParameterError('basename', 'string', options.basename);\n      }\n    }\n  }\n  // Format\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);\n  }\n  return this._updateFormatOut('dz');\n}\n\n/**\n * Set a timeout for processing, in seconds.\n * Use a value of zero to continue processing indefinitely, the default behaviour.\n *\n * The clock starts when libvips opens an input image for processing.\n * Time spent waiting for a libuv thread to become available is not included.\n *\n * @example\n * // Ensure processing takes no longer than 3 seconds\n * try {\n *   const data = await sharp(input)\n *     .blur(1000)\n *     .timeout({ seconds: 3 })\n *     .toBuffer();\n * } catch (err) {\n *   if (err.message.includes('timeout')) { ... }\n * }\n *\n * @since 0.29.2\n *\n * @param {Object} options\n * @param {number} options.seconds - Number of seconds after which processing will be stopped\n * @returns {Sharp}\n */\nfunction timeout(options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'object', options);\n  }\n  if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {\n    this.options.timeoutSeconds = options.seconds;\n  } else {\n    throw is.invalidParameterError('seconds', 'integer between 0 and 3600', options.seconds);\n  }\n  return this;\n}\n\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {string} formatOut\n * @param {Object} [options]\n * @param {boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\nfunction _updateFormatOut(formatOut, options) {\n  if (!(is.object(options) && options.force === false)) {\n    this.options.formatOut = formatOut;\n  }\n  return this;\n}\n\n/**\n * Update a boolean attribute of the this.options Object.\n * @private\n * @param {string} key\n * @param {boolean} val\n * @throws {Error} Invalid key\n */\nfunction _setBooleanOption(key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw is.invalidParameterError(key, 'boolean', val);\n  }\n}\n\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\nfunction _read() {\n  /* istanbul ignore else */\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n    this._pipeline();\n  }\n}\n\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\nfunction _pipeline(callback) {\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, callback);\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, callback);\n    }\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      this.once('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this.emit('info', info);\n            this.push(data);\n          }\n          this.push(null);\n          this.on('end', () => this.emit('close'));\n        });\n      });\n      if (this.streamInFinished) {\n        this.emit('finish');\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          this.emit('error', err);\n        } else {\n          this.emit('info', info);\n          this.push(data);\n        }\n        this.push(null);\n        this.on('end', () => this.emit('close'));\n      });\n    }\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise((resolve, reject) => {\n        this.once('finish', () => {\n          this._flattenBufferIn();\n          sharp.pipeline(this.options, (err, data, info) => {\n            if (err) {\n              reject(err);\n            } else {\n              if (this.options.resolveWithObject) {\n                resolve({\n                  data,\n                  info\n                });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise((resolve, reject) => {\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            reject(err);\n          } else {\n            if (this.options.resolveWithObject) {\n              resolve({\n                data: data,\n                info: info\n              });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    toFile,\n    toBuffer,\n    withMetadata,\n    toFormat,\n    jpeg,\n    jp2,\n    png,\n    webp,\n    tiff,\n    avif,\n    heif,\n    jxl,\n    gif,\n    raw,\n    tile,\n    timeout,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  });\n};","map":{"version":3,"names":["path","require","is","sharp","formats","Map","jp2Regex","errJp2Save","Error","bitdepthFromColourCount","colours","Math","clz32","ceil","log2","toFile","fileOut","callback","err","string","options","input","file","resolve","test","constructor","format","jp2k","output","fn","Promise","reject","_pipeline","toBuffer","object","_setBooleanOption","resolveWithObject","withMetadata","bool","defined","orientation","integer","inRange","withMetadataOrientation","invalidParameterError","density","number","withMetadataDensity","icc","withMetadataIcc","exif","ifd","entries","Object","k","v","withMetadataStrs","toLowerCase","toFormat","actualFormat","get","id","keys","join","jpeg","quality","jpegQuality","progressive","chromaSubsampling","inArray","jpegChromaSubsampling","optimiseCoding","optimizeCoding","mozjpeg","jpegTrellisQuantisation","jpegOvershootDeringing","jpegOptimiseScans","jpegProgressive","jpegQuantisationTable","trellisQuantisation","trellisQuantization","overshootDeringing","optimiseScans","optimizeScans","quantisationTable","quantizationTable","_updateFormatOut","png","compressionLevel","pngCompressionLevel","adaptiveFiltering","colors","pngBitdepth","palette","effort","dither","some","pngPalette","pngQuality","pngEffort","pngDither","webp","webpQuality","alphaQuality","webpAlphaQuality","lossless","nearLossless","smartSubsample","webpEffort","minSize","mixed","trySetAnimationOptions","gif","reuse","gifBitdepth","gifEffort","gifDither","interFrameMaxError","gifInterFrameMaxError","interPaletteMaxError","gifInterPaletteMaxError","jp2","buffer","jp2Quality","jp2Lossless","tileWidth","jp2TileWidth","tileHeight","jp2TileHeight","jp2ChromaSubsampling","source","target","loop","delay","Array","isArray","every","tiff","tiffQuality","bitdepth","tiffBitdepth","tile","tiffTileWidth","tiffTileHeight","pyramid","xres","tiffXres","yres","tiffYres","compression","tiffCompression","predictor","tiffPredictor","resolutionUnit","tiffResolutionUnit","avif","heif","heifQuality","heifLossless","heifCompression","heifEffort","heifChromaSubsampling","jxl","jxlDistance","distance","decodingTier","jxlDecodingTier","jxlLossless","jxlEffort","raw","depth","rawDepth","size","tileSize","overlap","tileOverlap","container","tileContainer","layout","tileLayout","angle","tileAngle","_setBackgroundColourOption","background","tileDepth","skipBlanks","tileSkipBlanks","centre","center","tileId","basename","tileBasename","formatOut","tileFormat","timeout","plainObject","seconds","timeoutSeconds","force","key","val","_read","streamOut","_isStreamInput","on","_flattenBufferIn","pipeline","once","data","info","emit","push","streamInFinished","module","exports","Sharp","assign","prototype"],"sources":["/Users/divyakulkarni/Desktop/IAMW/image-annotation-measurement/node_modules/sharp/lib/output.js"],"sourcesContent":["// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst path = require('path');\nconst is = require('./is');\nconst sharp = require('./sharp');\n\nconst formats = new Map([\n  ['heic', 'heif'],\n  ['heif', 'heif'],\n  ['avif', 'avif'],\n  ['jpeg', 'jpeg'],\n  ['jpg', 'jpeg'],\n  ['jpe', 'jpeg'],\n  ['tile', 'tile'],\n  ['dz', 'tile'],\n  ['png', 'png'],\n  ['raw', 'raw'],\n  ['tiff', 'tiff'],\n  ['tif', 'tiff'],\n  ['webp', 'webp'],\n  ['gif', 'gif'],\n  ['jp2', 'jp2'],\n  ['jpx', 'jp2'],\n  ['j2k', 'jp2'],\n  ['j2c', 'jp2'],\n  ['jxl', 'jxl']\n]);\n\nconst jp2Regex = /\\.jp[2x]|j2[kc]$/i;\n\nconst errJp2Save = () => new Error('JP2 output requires libvips with support for OpenJPEG');\n\nconst bitdepthFromColourCount = (colours) => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));\n\n/**\n * Write output image data to a file.\n *\n * If an explicit output format is not selected, it will be inferred from the extension,\n * with JPEG, PNG, WebP, AVIF, TIFF, GIF, DZI, and libvips' V format supported.\n * Note that raw pixel data is only supported for buffer output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * The caller is responsible for ensuring directory structures and permissions exist.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toFile('output.png', (err, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toFile('output.png')\n *   .then(info => { ... })\n *   .catch(err => { ... });\n *\n * @param {string} fileOut - the path to write the image data to.\n * @param {Function} [callback] - called on completion with two arguments `(err, info)`.\n * `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * When using the attention crop strategy also contains `attentionX` and `attentionY`, the focal point of the cropped region.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n * @returns {Promise<Object>} - when no callback is provided\n * @throws {Error} Invalid parameters\n */\nfunction toFile (fileOut, callback) {\n  let err;\n  if (!is.string(fileOut)) {\n    err = new Error('Missing output file path');\n  } else if (is.string(this.options.input.file) && path.resolve(this.options.input.file) === path.resolve(fileOut)) {\n    err = new Error('Cannot use same file for input and output');\n  } else if (jp2Regex.test(fileOut) && !this.constructor.format.jp2k.output.file) {\n    err = errJp2Save();\n  }\n  if (err) {\n    if (is.fn(callback)) {\n      callback(err);\n    } else {\n      return Promise.reject(err);\n    }\n  } else {\n    this.options.fileOut = fileOut;\n    return this._pipeline(callback);\n  }\n  return this;\n}\n\n/**\n * Write output to a Buffer.\n * JPEG, PNG, WebP, AVIF, TIFF, GIF and raw pixel data output are supported.\n *\n * Use {@link #toformat|toFormat} or one of the format-specific functions such as {@link jpeg}, {@link png} etc. to set the output format.\n *\n * If no explicit format is set, the output format will match the input image, except SVG input which becomes PNG output.\n *\n * By default all metadata will be removed, which includes EXIF-based orientation.\n * See {@link #withmetadata|withMetadata} for control over this.\n *\n * `callback`, if present, gets three arguments `(err, data, info)` where:\n * - `err` is an error, if any.\n * - `data` is the output image data.\n * - `info` contains the output image `format`, `size` (bytes), `width`, `height`,\n * `channels` and `premultiplied` (indicating if premultiplication was used).\n * When using a crop strategy also contains `cropOffsetLeft` and `cropOffsetTop`.\n * May also contain `textAutofitDpi` (dpi the font was rendered at) if image was created from text.\n *\n * A `Promise` is returned when `callback` is not provided.\n *\n * @example\n * sharp(input)\n *   .toBuffer((err, data, info) => { ... });\n *\n * @example\n * sharp(input)\n *   .toBuffer()\n *   .then(data => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * sharp(input)\n *   .png()\n *   .toBuffer({ resolveWithObject: true })\n *   .then(({ data, info }) => { ... })\n *   .catch(err => { ... });\n *\n * @example\n * const { data, info } = await sharp('my-image.jpg')\n *   // output the raw pixels\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * // create a more type safe way to work with the raw pixel data\n * // this will not copy the data, instead it will change `data`s underlying ArrayBuffer\n * // so `data` and `pixelArray` point to the same memory location\n * const pixelArray = new Uint8ClampedArray(data.buffer);\n *\n * // When you are done changing the pixelArray, sharp takes the `pixelArray` as an input\n * const { width, height, channels } = info;\n * await sharp(pixelArray, { raw: { width, height, channels } })\n *   .toFile('my-changed-image.jpg');\n *\n * @param {Object} [options]\n * @param {boolean} [options.resolveWithObject] Resolve the Promise with an Object containing `data` and `info` properties instead of resolving only with `data`.\n * @param {Function} [callback]\n * @returns {Promise<Buffer>} - when no callback is provided\n */\nfunction toBuffer (options, callback) {\n  if (is.object(options)) {\n    this._setBooleanOption('resolveWithObject', options.resolveWithObject);\n  } else if (this.options.resolveWithObject) {\n    this.options.resolveWithObject = false;\n  }\n  this.options.fileOut = '';\n  return this._pipeline(is.fn(options) ? options : callback);\n}\n\n/**\n * Include all metadata (EXIF, XMP, IPTC) from the input image in the output image.\n * This will also convert to and add a web-friendly sRGB ICC profile unless a custom\n * output profile is provided.\n *\n * The default behaviour, when `withMetadata` is not used, is to convert to the device-independent\n * sRGB colour space and strip all metadata, including the removal of any ICC profile.\n *\n * EXIF metadata is unsupported for TIFF output.\n *\n * @example\n * sharp('input.jpg')\n *   .withMetadata()\n *   .toFile('output-with-metadata.jpg')\n *   .then(info => { ... });\n *\n * @example\n * // Set output EXIF metadata\n * const data = await sharp(input)\n *   .withMetadata({\n *     exif: {\n *       IFD0: {\n *         Copyright: 'The National Gallery'\n *       },\n *       IFD3: {\n *         GPSLatitudeRef: 'N',\n *         GPSLatitude: '51/1 30/1 3230/100',\n *         GPSLongitudeRef: 'W',\n *         GPSLongitude: '0/1 7/1 4366/100'\n *       }\n *     }\n *   })\n *   .toBuffer();\n *\n * @example\n * // Set output metadata to 96 DPI\n * const data = await sharp(input)\n *   .withMetadata({ density: 96 })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {number} [options.orientation] value between 1 and 8, used to update the EXIF `Orientation` tag.\n * @param {string} [options.icc='srgb'] Filesystem path to output ICC profile, relative to `process.cwd()`, defaults to built-in sRGB.\n * @param {Object<Object>} [options.exif={}] Object keyed by IFD0, IFD1 etc. of key/value string pairs to write as EXIF data.\n * @param {number} [options.density] Number of pixels per inch (DPI).\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction withMetadata (options) {\n  this.options.withMetadata = is.bool(options) ? options : true;\n  if (is.object(options)) {\n    if (is.defined(options.orientation)) {\n      if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {\n        this.options.withMetadataOrientation = options.orientation;\n      } else {\n        throw is.invalidParameterError('orientation', 'integer between 1 and 8', options.orientation);\n      }\n    }\n    if (is.defined(options.density)) {\n      if (is.number(options.density) && options.density > 0) {\n        this.options.withMetadataDensity = options.density;\n      } else {\n        throw is.invalidParameterError('density', 'positive number', options.density);\n      }\n    }\n    if (is.defined(options.icc)) {\n      if (is.string(options.icc)) {\n        this.options.withMetadataIcc = options.icc;\n      } else {\n        throw is.invalidParameterError('icc', 'string filesystem path to ICC profile', options.icc);\n      }\n    }\n    if (is.defined(options.exif)) {\n      if (is.object(options.exif)) {\n        for (const [ifd, entries] of Object.entries(options.exif)) {\n          if (is.object(entries)) {\n            for (const [k, v] of Object.entries(entries)) {\n              if (is.string(v)) {\n                this.options.withMetadataStrs[`exif-${ifd.toLowerCase()}-${k}`] = v;\n              } else {\n                throw is.invalidParameterError(`exif.${ifd}.${k}`, 'string', v);\n              }\n            }\n          } else {\n            throw is.invalidParameterError(`exif.${ifd}`, 'object', entries);\n          }\n        }\n      } else {\n        throw is.invalidParameterError('exif', 'object', options.exif);\n      }\n    }\n  }\n  return this;\n}\n\n/**\n * Force output to a given format.\n *\n * @example\n * // Convert any input to PNG output\n * const data = await sharp(input)\n *   .toFormat('png')\n *   .toBuffer();\n *\n * @param {(string|Object)} format - as a string or an Object with an 'id' attribute\n * @param {Object} options - output options\n * @returns {Sharp}\n * @throws {Error} unsupported format or options\n */\nfunction toFormat (format, options) {\n  const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());\n  if (!actualFormat) {\n    throw is.invalidParameterError('format', `one of: ${[...formats.keys()].join(', ')}`, format);\n  }\n  return this[actualFormat](options);\n}\n\n/**\n * Use these JPEG options for output image.\n *\n * @example\n * // Convert any input to very high quality JPEG output\n * const data = await sharp(input)\n *   .jpeg({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @example\n * // Use mozjpeg to reduce output JPEG file size (slower)\n * const data = await sharp(input)\n *   .jpeg({ mozjpeg: true })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {string} [options.chromaSubsampling='4:2:0'] - set to '4:4:4' to prevent chroma subsampling otherwise defaults to '4:2:0' chroma subsampling\n * @param {boolean} [options.optimiseCoding=true] - optimise Huffman coding tables\n * @param {boolean} [options.optimizeCoding=true] - alternative spelling of optimiseCoding\n * @param {boolean} [options.mozjpeg=false] - use mozjpeg defaults, equivalent to `{ trellisQuantisation: true, overshootDeringing: true, optimiseScans: true, quantisationTable: 3 }`\n * @param {boolean} [options.trellisQuantisation=false] - apply trellis quantisation\n * @param {boolean} [options.overshootDeringing=false] - apply overshoot deringing\n * @param {boolean} [options.optimiseScans=false] - optimise progressive scans, forces progressive\n * @param {boolean} [options.optimizeScans=false] - alternative spelling of optimiseScans\n * @param {number} [options.quantisationTable=0] - quantization table to use, integer 0-8\n * @param {number} [options.quantizationTable=0] - alternative spelling of quantisationTable\n * @param {boolean} [options.force=true] - force JPEG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jpeg (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jpegQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('jpegProgressive', options.progressive);\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jpegChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n    const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;\n    if (is.defined(optimiseCoding)) {\n      this._setBooleanOption('jpegOptimiseCoding', optimiseCoding);\n    }\n    if (is.defined(options.mozjpeg)) {\n      if (is.bool(options.mozjpeg)) {\n        if (options.mozjpeg) {\n          this.options.jpegTrellisQuantisation = true;\n          this.options.jpegOvershootDeringing = true;\n          this.options.jpegOptimiseScans = true;\n          this.options.jpegProgressive = true;\n          this.options.jpegQuantisationTable = 3;\n        }\n      } else {\n        throw is.invalidParameterError('mozjpeg', 'boolean', options.mozjpeg);\n      }\n    }\n    const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;\n    if (is.defined(trellisQuantisation)) {\n      this._setBooleanOption('jpegTrellisQuantisation', trellisQuantisation);\n    }\n    if (is.defined(options.overshootDeringing)) {\n      this._setBooleanOption('jpegOvershootDeringing', options.overshootDeringing);\n    }\n    const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;\n    if (is.defined(optimiseScans)) {\n      this._setBooleanOption('jpegOptimiseScans', optimiseScans);\n      if (optimiseScans) {\n        this.options.jpegProgressive = true;\n      }\n    }\n    const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;\n    if (is.defined(quantisationTable)) {\n      if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {\n        this.options.jpegQuantisationTable = quantisationTable;\n      } else {\n        throw is.invalidParameterError('quantisationTable', 'integer between 0 and 8', quantisationTable);\n      }\n    }\n  }\n  return this._updateFormatOut('jpeg', options);\n}\n\n/**\n * Use these PNG options for output image.\n *\n * By default, PNG output is full colour at 8 or 16 bits per pixel.\n * Indexed PNG input at 1, 2 or 4 bits per pixel is converted to 8 bits per pixel.\n * Set `palette` to `true` for slower, indexed PNG output.\n *\n * @example\n * // Convert any input to full colour PNG output\n * const data = await sharp(input)\n *   .png()\n *   .toBuffer();\n *\n * @example\n * // Convert any input to indexed PNG output (slower)\n * const data = await sharp(input)\n *   .png({ palette: true })\n *   .toBuffer();\n *\n * @param {Object} [options]\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.compressionLevel=6] - zlib compression level, 0 (fastest, largest) to 9 (slowest, smallest)\n * @param {boolean} [options.adaptiveFiltering=false] - use adaptive row filtering\n * @param {boolean} [options.palette=false] - quantise to a palette-based image with alpha transparency support\n * @param {number} [options.quality=100] - use the lowest number of colours needed to achieve given quality, sets `palette` to `true`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest), sets `palette` to `true`\n * @param {number} [options.colours=256] - maximum number of palette entries, sets `palette` to `true`\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`, sets `palette` to `true`\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, sets `palette` to `true`\n * @param {boolean} [options.force=true] - force PNG output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction png (options) {\n  if (is.object(options)) {\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('pngProgressive', options.progressive);\n    }\n    if (is.defined(options.compressionLevel)) {\n      if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {\n        this.options.pngCompressionLevel = options.compressionLevel;\n      } else {\n        throw is.invalidParameterError('compressionLevel', 'integer between 0 and 9', options.compressionLevel);\n      }\n    }\n    if (is.defined(options.adaptiveFiltering)) {\n      this._setBooleanOption('pngAdaptiveFiltering', options.adaptiveFiltering);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.pngBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.palette)) {\n      this._setBooleanOption('pngPalette', options.palette);\n    } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {\n      this._setBooleanOption('pngPalette', true);\n    }\n    if (this.options.pngPalette) {\n      if (is.defined(options.quality)) {\n        if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {\n          this.options.pngQuality = options.quality;\n        } else {\n          throw is.invalidParameterError('quality', 'integer between 0 and 100', options.quality);\n        }\n      }\n      if (is.defined(options.effort)) {\n        if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {\n          this.options.pngEffort = options.effort;\n        } else {\n          throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n        }\n      }\n      if (is.defined(options.dither)) {\n        if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n          this.options.pngDither = options.dither;\n        } else {\n          throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n        }\n      }\n    }\n  }\n  return this._updateFormatOut('png', options);\n}\n\n/**\n * Use these WebP options for output image.\n *\n * @example\n * // Convert any input to lossless WebP output\n * const data = await sharp(input)\n *   .webp({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Optimise the file size of an animated WebP\n * const outputWebp = await sharp(inputWebp, { animated: true })\n *   .webp({ effort: 6 })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {number} [options.alphaQuality=100] - quality of alpha layer, integer 0-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {boolean} [options.nearLossless=false] - use near_lossless compression mode\n * @param {boolean} [options.smartSubsample=false] - use high quality chroma subsampling\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 6 (slowest)\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.minSize=false] - prevent use of animation key frames to minimise file size (slow)\n * @param {boolean} [options.mixed=false] - allow mixture of lossy and lossless animation frames (slow)\n * @param {boolean} [options.force=true] - force WebP output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction webp (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.webpQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.alphaQuality)) {\n      if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {\n        this.options.webpAlphaQuality = options.alphaQuality;\n      } else {\n        throw is.invalidParameterError('alphaQuality', 'integer between 0 and 100', options.alphaQuality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      this._setBooleanOption('webpLossless', options.lossless);\n    }\n    if (is.defined(options.nearLossless)) {\n      this._setBooleanOption('webpNearLossless', options.nearLossless);\n    }\n    if (is.defined(options.smartSubsample)) {\n      this._setBooleanOption('webpSmartSubsample', options.smartSubsample);\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 6)) {\n        this.options.webpEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 6', options.effort);\n      }\n    }\n    if (is.defined(options.minSize)) {\n      this._setBooleanOption('webpMinSize', options.minSize);\n    }\n    if (is.defined(options.mixed)) {\n      this._setBooleanOption('webpMixed', options.mixed);\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('webp', options);\n}\n\n/**\n * Use these GIF options for the output image.\n *\n * The first entry in the palette is reserved for transparency.\n *\n * The palette of the input image will be re-used if possible.\n *\n * @since 0.30.0\n *\n * @example\n * // Convert PNG to GIF\n * await sharp(pngBuffer)\n *   .gif()\n *   .toBuffer();\n *\n * @example\n * // Convert animated WebP to animated GIF\n * await sharp('animated.webp', { animated: true })\n *   .toFile('animated.gif');\n *\n * @example\n * // Create a 128x128, cropped, non-dithered, animated thumbnail of an animated GIF\n * const out = await sharp('in.gif', { animated: true })\n *   .resize({ width: 128, height: 128 })\n *   .gif({ dither: 0 })\n *   .toBuffer();\n *\n * @example\n * // Lossy file size reduction of animated GIF\n * await sharp('in.gif', { animated: true })\n *   .gif({ interFrameMaxError: 8 })\n *   .toFile('optim.gif');\n *\n * @param {Object} [options] - output options\n * @param {boolean} [options.reuse=true] - re-use existing palette, otherwise generate new (slow)\n * @param {boolean} [options.progressive=false] - use progressive (interlace) scan\n * @param {number} [options.colours=256] - maximum number of palette entries, including transparency, between 2 and 256\n * @param {number} [options.colors=256] - alternative spelling of `options.colours`\n * @param {number} [options.effort=7] - CPU effort, between 1 (fastest) and 10 (slowest)\n * @param {number} [options.dither=1.0] - level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most)\n * @param {number} [options.interFrameMaxError=0] - maximum inter-frame error for transparency, between 0 (lossless) and 32\n * @param {number} [options.interPaletteMaxError=3] - maximum inter-palette error for palette reuse, between 0 and 256\n * @param {number} [options.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number|number[]} [options.delay] - delay(s) between animation frames (in milliseconds)\n * @param {boolean} [options.force=true] - force GIF output, otherwise attempt to use input format\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction gif (options) {\n  if (is.object(options)) {\n    if (is.defined(options.reuse)) {\n      this._setBooleanOption('gifReuse', options.reuse);\n    }\n    if (is.defined(options.progressive)) {\n      this._setBooleanOption('gifProgressive', options.progressive);\n    }\n    const colours = options.colours || options.colors;\n    if (is.defined(colours)) {\n      if (is.integer(colours) && is.inRange(colours, 2, 256)) {\n        this.options.gifBitdepth = bitdepthFromColourCount(colours);\n      } else {\n        throw is.invalidParameterError('colours', 'integer between 2 and 256', colours);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {\n        this.options.gifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 1 and 10', options.effort);\n      }\n    }\n    if (is.defined(options.dither)) {\n      if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {\n        this.options.gifDither = options.dither;\n      } else {\n        throw is.invalidParameterError('dither', 'number between 0.0 and 1.0', options.dither);\n      }\n    }\n    if (is.defined(options.interFrameMaxError)) {\n      if (is.number(options.interFrameMaxError) && is.inRange(options.interFrameMaxError, 0, 32)) {\n        this.options.gifInterFrameMaxError = options.interFrameMaxError;\n      } else {\n        throw is.invalidParameterError('interFrameMaxError', 'number between 0.0 and 32.0', options.interFrameMaxError);\n      }\n    }\n    if (is.defined(options.interPaletteMaxError)) {\n      if (is.number(options.interPaletteMaxError) && is.inRange(options.interPaletteMaxError, 0, 256)) {\n        this.options.gifInterPaletteMaxError = options.interPaletteMaxError;\n      } else {\n        throw is.invalidParameterError('interPaletteMaxError', 'number between 0.0 and 256.0', options.interPaletteMaxError);\n      }\n    }\n  }\n  trySetAnimationOptions(options, this.options);\n  return this._updateFormatOut('gif', options);\n}\n\n/* istanbul ignore next */\n/**\n * Use these JP2 options for output image.\n *\n * Requires libvips compiled with support for OpenJPEG.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n * // Convert any input to lossless JP2 output\n * const data = await sharp(input)\n *   .jp2({ lossless: true })\n *   .toBuffer();\n *\n * @example\n * // Convert any input to very high quality JP2 output\n * const data = await sharp(input)\n *   .jp2({\n *     quality: 100,\n *     chromaSubsampling: '4:4:4'\n *   })\n *   .toBuffer();\n *\n * @since 0.29.1\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression mode\n * @param {number} [options.tileWidth=512] - horizontal tile size\n * @param {number} [options.tileHeight=512] - vertical tile size\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jp2 (options) {\n  if (!this.constructor.format.jp2k.output.buffer) {\n    throw errJp2Save();\n  }\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.jp2Quality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jp2Lossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {\n        this.options.jp2TileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer between 1 and 32768', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {\n        this.options.jp2TileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer between 1 and 32768', options.tileHeight);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.jp2ChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('jp2', options);\n}\n\n/**\n * Set animation options if available.\n * @private\n *\n * @param {Object} [source] - output options\n * @param {number} [source.loop=0] - number of animation iterations, use 0 for infinite animation\n * @param {number[]} [source.delay] - list of delays between animation frames (in milliseconds)\n * @param {Object} [target] - target object for valid options\n * @throws {Error} Invalid options\n */\nfunction trySetAnimationOptions (source, target) {\n  if (is.object(source) && is.defined(source.loop)) {\n    if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {\n      target.loop = source.loop;\n    } else {\n      throw is.invalidParameterError('loop', 'integer between 0 and 65535', source.loop);\n    }\n  }\n  if (is.object(source) && is.defined(source.delay)) {\n    // We allow singular values as well\n    if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {\n      target.delay = [source.delay];\n    } else if (\n      Array.isArray(source.delay) &&\n      source.delay.every(is.integer) &&\n      source.delay.every(v => is.inRange(v, 0, 65535))) {\n      target.delay = source.delay;\n    } else {\n      throw is.invalidParameterError('delay', 'integer or an array of integers between 0 and 65535', source.delay);\n    }\n  }\n}\n\n/**\n * Use these TIFF options for output image.\n *\n * The `density` can be set in pixels/inch via {@link #withmetadata|withMetadata}\n * instead of providing `xres` and `yres` in pixels/mm.\n *\n * @example\n * // Convert SVG input to LZW-compressed, 1 bit per pixel TIFF output\n * sharp('input.svg')\n *   .tiff({\n *     compression: 'lzw',\n *     bitdepth: 1\n *   })\n *   .toFile('1-bpp-output.tiff')\n *   .then(info => { ... });\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=80] - quality, integer 1-100\n * @param {boolean} [options.force=true] - force TIFF output, otherwise attempt to use input format\n * @param {string} [options.compression='jpeg'] - compression options: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k\n * @param {string} [options.predictor='horizontal'] - compression predictor options: none, horizontal, float\n * @param {boolean} [options.pyramid=false] - write an image pyramid\n * @param {boolean} [options.tile=false] - write a tiled tiff\n * @param {number} [options.tileWidth=256] - horizontal tile size\n * @param {number} [options.tileHeight=256] - vertical tile size\n * @param {number} [options.xres=1.0] - horizontal resolution in pixels/mm\n * @param {number} [options.yres=1.0] - vertical resolution in pixels/mm\n * @param {string} [options.resolutionUnit='inch'] - resolution unit options: inch, cm\n * @param {number} [options.bitdepth=8] - reduce bitdepth to 1, 2 or 4 bit\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction tiff (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.tiffQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.bitdepth)) {\n      if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {\n        this.options.tiffBitdepth = options.bitdepth;\n      } else {\n        throw is.invalidParameterError('bitdepth', '1, 2, 4 or 8', options.bitdepth);\n      }\n    }\n    // tiling\n    if (is.defined(options.tile)) {\n      this._setBooleanOption('tiffTile', options.tile);\n    }\n    if (is.defined(options.tileWidth)) {\n      if (is.integer(options.tileWidth) && options.tileWidth > 0) {\n        this.options.tiffTileWidth = options.tileWidth;\n      } else {\n        throw is.invalidParameterError('tileWidth', 'integer greater than zero', options.tileWidth);\n      }\n    }\n    if (is.defined(options.tileHeight)) {\n      if (is.integer(options.tileHeight) && options.tileHeight > 0) {\n        this.options.tiffTileHeight = options.tileHeight;\n      } else {\n        throw is.invalidParameterError('tileHeight', 'integer greater than zero', options.tileHeight);\n      }\n    }\n    // pyramid\n    if (is.defined(options.pyramid)) {\n      this._setBooleanOption('tiffPyramid', options.pyramid);\n    }\n    // resolution\n    if (is.defined(options.xres)) {\n      if (is.number(options.xres) && options.xres > 0) {\n        this.options.tiffXres = options.xres;\n      } else {\n        throw is.invalidParameterError('xres', 'number greater than zero', options.xres);\n      }\n    }\n    if (is.defined(options.yres)) {\n      if (is.number(options.yres) && options.yres > 0) {\n        this.options.tiffYres = options.yres;\n      } else {\n        throw is.invalidParameterError('yres', 'number greater than zero', options.yres);\n      }\n    }\n    // compression\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['none', 'jpeg', 'deflate', 'packbits', 'ccittfax4', 'lzw', 'webp', 'zstd', 'jp2k'])) {\n        this.options.tiffCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k', options.compression);\n      }\n    }\n    // predictor\n    if (is.defined(options.predictor)) {\n      if (is.string(options.predictor) && is.inArray(options.predictor, ['none', 'horizontal', 'float'])) {\n        this.options.tiffPredictor = options.predictor;\n      } else {\n        throw is.invalidParameterError('predictor', 'one of: none, horizontal, float', options.predictor);\n      }\n    }\n    // resolutionUnit\n    if (is.defined(options.resolutionUnit)) {\n      if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ['inch', 'cm'])) {\n        this.options.tiffResolutionUnit = options.resolutionUnit;\n      } else {\n        throw is.invalidParameterError('resolutionUnit', 'one of: inch, cm', options.resolutionUnit);\n      }\n    }\n  }\n  return this._updateFormatOut('tiff', options);\n}\n\n/**\n * Use these AVIF options for output image.\n *\n * Whilst it is possible to create AVIF images smaller than 16x16 pixels,\n * most web browsers do not display these properly.\n *\n * AVIF image sequences are not supported.\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ effort: 2 })\n *   .toBuffer();\n *\n * @example\n * const data = await sharp(input)\n *   .avif({ lossless: true })\n *   .toBuffer();\n *\n * @since 0.27.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction avif (options) {\n  return this.heif({ ...options, compression: 'av1' });\n}\n\n/**\n * Use these HEIF options for output image.\n *\n * Support for patent-encumbered HEIC images using `hevc` compression requires the use of a\n * globally-installed libvips compiled with support for libheif, libde265 and x265.\n *\n * @example\n * const data = await sharp(input)\n *   .heif({ compression: 'hevc' })\n *   .toBuffer();\n *\n * @since 0.23.0\n *\n * @param {Object} [options] - output options\n * @param {number} [options.quality=50] - quality, integer 1-100\n * @param {string} [options.compression='av1'] - compression format: av1, hevc\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=4] - CPU effort, between 0 (fastest) and 9 (slowest)\n * @param {string} [options.chromaSubsampling='4:4:4'] - set to '4:2:0' to use chroma subsampling\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction heif (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        this.options.heifQuality = options.quality;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.heifLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.compression)) {\n      if (is.string(options.compression) && is.inArray(options.compression, ['av1', 'hevc'])) {\n        this.options.heifCompression = options.compression;\n      } else {\n        throw is.invalidParameterError('compression', 'one of: av1, hevc', options.compression);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {\n        this.options.heifEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 0 and 9', options.effort);\n      }\n    }\n    if (is.defined(options.chromaSubsampling)) {\n      if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ['4:2:0', '4:4:4'])) {\n        this.options.heifChromaSubsampling = options.chromaSubsampling;\n      } else {\n        throw is.invalidParameterError('chromaSubsampling', 'one of: 4:2:0, 4:4:4', options.chromaSubsampling);\n      }\n    }\n  }\n  return this._updateFormatOut('heif', options);\n}\n\n/**\n * Use these JPEG-XL (JXL) options for output image.\n *\n * This feature is experimental, please do not use in production systems.\n *\n * Requires libvips compiled with support for libjxl.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * Image metadata (EXIF, XMP) is unsupported.\n *\n * @since 0.31.3\n *\n * @param {Object} [options] - output options\n * @param {number} [options.distance=1.0] - maximum encoding error, between 0 (highest quality) and 15 (lowest quality)\n * @param {number} [options.quality] - calculate `distance` based on JPEG-like quality, between 1 and 100, overrides distance if specified\n * @param {number} [options.decodingTier=0] - target decode speed tier, between 0 (highest quality) and 4 (lowest quality)\n * @param {boolean} [options.lossless=false] - use lossless compression\n * @param {number} [options.effort=7] - CPU effort, between 3 (fastest) and 9 (slowest)\n * @returns {Sharp}\n * @throws {Error} Invalid options\n */\nfunction jxl (options) {\n  if (is.object(options)) {\n    if (is.defined(options.quality)) {\n      if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {\n        // https://github.com/libjxl/libjxl/blob/0aeea7f180bafd6893c1db8072dcb67d2aa5b03d/tools/cjxl_main.cc#L640-L644\n        this.options.jxlDistance = options.quality >= 30\n          ? 0.1 + (100 - options.quality) * 0.09\n          : 53 / 3000 * options.quality * options.quality - 23 / 20 * options.quality + 25;\n      } else {\n        throw is.invalidParameterError('quality', 'integer between 1 and 100', options.quality);\n      }\n    } else if (is.defined(options.distance)) {\n      if (is.number(options.distance) && is.inRange(options.distance, 0, 15)) {\n        this.options.jxlDistance = options.distance;\n      } else {\n        throw is.invalidParameterError('distance', 'number between 0.0 and 15.0', options.distance);\n      }\n    }\n    if (is.defined(options.decodingTier)) {\n      if (is.integer(options.decodingTier) && is.inRange(options.decodingTier, 0, 4)) {\n        this.options.jxlDecodingTier = options.decodingTier;\n      } else {\n        throw is.invalidParameterError('decodingTier', 'integer between 0 and 4', options.decodingTier);\n      }\n    }\n    if (is.defined(options.lossless)) {\n      if (is.bool(options.lossless)) {\n        this.options.jxlLossless = options.lossless;\n      } else {\n        throw is.invalidParameterError('lossless', 'boolean', options.lossless);\n      }\n    }\n    if (is.defined(options.effort)) {\n      if (is.integer(options.effort) && is.inRange(options.effort, 3, 9)) {\n        this.options.jxlEffort = options.effort;\n      } else {\n        throw is.invalidParameterError('effort', 'integer between 3 and 9', options.effort);\n      }\n    }\n  }\n  return this._updateFormatOut('jxl', options);\n}\n\n/**\n * Force output to be raw, uncompressed pixel data.\n * Pixel ordering is left-to-right, top-to-bottom, without padding.\n * Channel ordering will be RGB or RGBA for non-greyscale colourspaces.\n *\n * @example\n * // Extract raw, unsigned 8-bit RGB pixel data from JPEG input\n * const { data, info } = await sharp('input.jpg')\n *   .raw()\n *   .toBuffer({ resolveWithObject: true });\n *\n * @example\n * // Extract alpha channel as raw, unsigned 16-bit pixel data from PNG input\n * const data = await sharp('input.png')\n *   .ensureAlpha()\n *   .extractChannel(3)\n *   .toColourspace('b-w')\n *   .raw({ depth: 'ushort' })\n *   .toBuffer();\n *\n * @param {Object} [options] - output options\n * @param {string} [options.depth='uchar'] - bit depth, one of: char, uchar (default), short, ushort, int, uint, float, complex, double, dpcomplex\n * @throws {Error} Invalid options\n */\nfunction raw (options) {\n  if (is.object(options)) {\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth,\n        ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'complex', 'double', 'dpcomplex']\n      )) {\n        this.options.rawDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex', options.depth);\n      }\n    }\n  }\n  return this._updateFormatOut('raw');\n}\n\n/**\n * Use tile-based deep zoom (image pyramid) output.\n *\n * Set the format and options for tile images via the `toFormat`, `jpeg`, `png` or `webp` functions.\n * Use a `.zip` or `.szi` file extension with `toFile` to write to a compressed archive file format.\n *\n * The container will be set to `zip` when the output is a Buffer or Stream, otherwise it will default to `fs`.\n *\n * Requires libvips compiled with support for libgsf.\n * The prebuilt binaries do not include this - see\n * {@link https://sharp.pixelplumbing.com/install#custom-libvips installing a custom libvips}.\n *\n * @example\n *  sharp('input.tiff')\n *   .png()\n *   .tile({\n *     size: 512\n *   })\n *   .toFile('output.dz', function(err, info) {\n *     // output.dzi is the Deep Zoom XML definition\n *     // output_files contains 512x512 tiles grouped by zoom level\n *   });\n *\n * @example\n * const zipFileWithTiles = await sharp(input)\n *   .tile({ basename: \"tiles\" })\n *   .toBuffer();\n *\n * @example\n * const iiififier = sharp().tile({ layout: \"iiif\" });\n * readableStream\n *   .pipe(iiififier)\n *   .pipe(writeableStream);\n *\n * @param {Object} [options]\n * @param {number} [options.size=256] tile size in pixels, a value between 1 and 8192.\n * @param {number} [options.overlap=0] tile overlap in pixels, a value between 0 and 8192.\n * @param {number} [options.angle=0] tile angle of rotation, must be a multiple of 90.\n * @param {string|Object} [options.background={r: 255, g: 255, b: 255, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to white without transparency.\n * @param {string} [options.depth] how deep to make the pyramid, possible values are `onepixel`, `onetile` or `one`, default based on layout.\n * @param {number} [options.skipBlanks=-1] threshold to skip tile generation, a value 0 - 255 for 8-bit images or 0 - 65535 for 16-bit images\n * @param {string} [options.container='fs'] tile container, with value `fs` (filesystem) or `zip` (compressed file).\n * @param {string} [options.layout='dz'] filesystem layout, possible values are `dz`, `iiif`, `iiif3`, `zoomify` or `google`.\n * @param {boolean} [options.centre=false] centre image in tile.\n * @param {boolean} [options.center=false] alternative spelling of centre.\n * @param {string} [options.id='https://example.com/iiif'] when `layout` is `iiif`/`iiif3`, sets the `@id`/`id` attribute of `info.json`\n * @param {string} [options.basename] the name of the directory within the zip file when container is `zip`.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction tile (options) {\n  if (is.object(options)) {\n    // Size of square tiles, in pixels\n    if (is.defined(options.size)) {\n      if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {\n        this.options.tileSize = options.size;\n      } else {\n        throw is.invalidParameterError('size', 'integer between 1 and 8192', options.size);\n      }\n    }\n    // Overlap of tiles, in pixels\n    if (is.defined(options.overlap)) {\n      if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {\n        if (options.overlap > this.options.tileSize) {\n          throw is.invalidParameterError('overlap', `<= size (${this.options.tileSize})`, options.overlap);\n        }\n        this.options.tileOverlap = options.overlap;\n      } else {\n        throw is.invalidParameterError('overlap', 'integer between 0 and 8192', options.overlap);\n      }\n    }\n    // Container\n    if (is.defined(options.container)) {\n      if (is.string(options.container) && is.inArray(options.container, ['fs', 'zip'])) {\n        this.options.tileContainer = options.container;\n      } else {\n        throw is.invalidParameterError('container', 'one of: fs, zip', options.container);\n      }\n    }\n    // Layout\n    if (is.defined(options.layout)) {\n      if (is.string(options.layout) && is.inArray(options.layout, ['dz', 'google', 'iiif', 'iiif3', 'zoomify'])) {\n        this.options.tileLayout = options.layout;\n      } else {\n        throw is.invalidParameterError('layout', 'one of: dz, google, iiif, iiif3, zoomify', options.layout);\n      }\n    }\n    // Angle of rotation,\n    if (is.defined(options.angle)) {\n      if (is.integer(options.angle) && !(options.angle % 90)) {\n        this.options.tileAngle = options.angle;\n      } else {\n        throw is.invalidParameterError('angle', 'positive/negative multiple of 90', options.angle);\n      }\n    }\n    // Background colour\n    this._setBackgroundColourOption('tileBackground', options.background);\n    // Depth of tiles\n    if (is.defined(options.depth)) {\n      if (is.string(options.depth) && is.inArray(options.depth, ['onepixel', 'onetile', 'one'])) {\n        this.options.tileDepth = options.depth;\n      } else {\n        throw is.invalidParameterError('depth', 'one of: onepixel, onetile, one', options.depth);\n      }\n    }\n    // Threshold to skip blank tiles\n    if (is.defined(options.skipBlanks)) {\n      if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {\n        this.options.tileSkipBlanks = options.skipBlanks;\n      } else {\n        throw is.invalidParameterError('skipBlanks', 'integer between -1 and 255/65535', options.skipBlanks);\n      }\n    } else if (is.defined(options.layout) && options.layout === 'google') {\n      this.options.tileSkipBlanks = 5;\n    }\n    // Center image in tile\n    const centre = is.bool(options.center) ? options.center : options.centre;\n    if (is.defined(centre)) {\n      this._setBooleanOption('tileCentre', centre);\n    }\n    // @id attribute for IIIF layout\n    if (is.defined(options.id)) {\n      if (is.string(options.id)) {\n        this.options.tileId = options.id;\n      } else {\n        throw is.invalidParameterError('id', 'string', options.id);\n      }\n    }\n    // Basename for zip container\n    if (is.defined(options.basename)) {\n      if (is.string(options.basename)) {\n        this.options.tileBasename = options.basename;\n      } else {\n        throw is.invalidParameterError('basename', 'string', options.basename);\n      }\n    }\n  }\n  // Format\n  if (is.inArray(this.options.formatOut, ['jpeg', 'png', 'webp'])) {\n    this.options.tileFormat = this.options.formatOut;\n  } else if (this.options.formatOut !== 'input') {\n    throw is.invalidParameterError('format', 'one of: jpeg, png, webp', this.options.formatOut);\n  }\n  return this._updateFormatOut('dz');\n}\n\n/**\n * Set a timeout for processing, in seconds.\n * Use a value of zero to continue processing indefinitely, the default behaviour.\n *\n * The clock starts when libvips opens an input image for processing.\n * Time spent waiting for a libuv thread to become available is not included.\n *\n * @example\n * // Ensure processing takes no longer than 3 seconds\n * try {\n *   const data = await sharp(input)\n *     .blur(1000)\n *     .timeout({ seconds: 3 })\n *     .toBuffer();\n * } catch (err) {\n *   if (err.message.includes('timeout')) { ... }\n * }\n *\n * @since 0.29.2\n *\n * @param {Object} options\n * @param {number} options.seconds - Number of seconds after which processing will be stopped\n * @returns {Sharp}\n */\nfunction timeout (options) {\n  if (!is.plainObject(options)) {\n    throw is.invalidParameterError('options', 'object', options);\n  }\n  if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {\n    this.options.timeoutSeconds = options.seconds;\n  } else {\n    throw is.invalidParameterError('seconds', 'integer between 0 and 3600', options.seconds);\n  }\n  return this;\n}\n\n/**\n * Update the output format unless options.force is false,\n * in which case revert to input format.\n * @private\n * @param {string} formatOut\n * @param {Object} [options]\n * @param {boolean} [options.force=true] - force output format, otherwise attempt to use input format\n * @returns {Sharp}\n */\nfunction _updateFormatOut (formatOut, options) {\n  if (!(is.object(options) && options.force === false)) {\n    this.options.formatOut = formatOut;\n  }\n  return this;\n}\n\n/**\n * Update a boolean attribute of the this.options Object.\n * @private\n * @param {string} key\n * @param {boolean} val\n * @throws {Error} Invalid key\n */\nfunction _setBooleanOption (key, val) {\n  if (is.bool(val)) {\n    this.options[key] = val;\n  } else {\n    throw is.invalidParameterError(key, 'boolean', val);\n  }\n}\n\n/**\n * Called by a WriteableStream to notify us it is ready for data.\n * @private\n */\nfunction _read () {\n  /* istanbul ignore else */\n  if (!this.options.streamOut) {\n    this.options.streamOut = true;\n    this._pipeline();\n  }\n}\n\n/**\n * Invoke the C++ image processing pipeline\n * Supports callback, stream and promise variants\n * @private\n */\nfunction _pipeline (callback) {\n  if (typeof callback === 'function') {\n    // output=file/buffer\n    if (this._isStreamInput()) {\n      // output=file/buffer, input=stream\n      this.on('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, callback);\n      });\n    } else {\n      // output=file/buffer, input=file/buffer\n      sharp.pipeline(this.options, callback);\n    }\n    return this;\n  } else if (this.options.streamOut) {\n    // output=stream\n    if (this._isStreamInput()) {\n      // output=stream, input=stream\n      this.once('finish', () => {\n        this._flattenBufferIn();\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this.emit('info', info);\n            this.push(data);\n          }\n          this.push(null);\n          this.on('end', () => this.emit('close'));\n        });\n      });\n      if (this.streamInFinished) {\n        this.emit('finish');\n      }\n    } else {\n      // output=stream, input=file/buffer\n      sharp.pipeline(this.options, (err, data, info) => {\n        if (err) {\n          this.emit('error', err);\n        } else {\n          this.emit('info', info);\n          this.push(data);\n        }\n        this.push(null);\n        this.on('end', () => this.emit('close'));\n      });\n    }\n    return this;\n  } else {\n    // output=promise\n    if (this._isStreamInput()) {\n      // output=promise, input=stream\n      return new Promise((resolve, reject) => {\n        this.once('finish', () => {\n          this._flattenBufferIn();\n          sharp.pipeline(this.options, (err, data, info) => {\n            if (err) {\n              reject(err);\n            } else {\n              if (this.options.resolveWithObject) {\n                resolve({ data, info });\n              } else {\n                resolve(data);\n              }\n            }\n          });\n        });\n      });\n    } else {\n      // output=promise, input=file/buffer\n      return new Promise((resolve, reject) => {\n        sharp.pipeline(this.options, (err, data, info) => {\n          if (err) {\n            reject(err);\n          } else {\n            if (this.options.resolveWithObject) {\n              resolve({ data: data, info: info });\n            } else {\n              resolve(data);\n            }\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Decorate the Sharp prototype with output-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    // Public\n    toFile,\n    toBuffer,\n    withMetadata,\n    toFormat,\n    jpeg,\n    jp2,\n    png,\n    webp,\n    tiff,\n    avif,\n    heif,\n    jxl,\n    gif,\n    raw,\n    tile,\n    timeout,\n    // Private\n    _updateFormatOut,\n    _setBooleanOption,\n    _read,\n    _pipeline\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}