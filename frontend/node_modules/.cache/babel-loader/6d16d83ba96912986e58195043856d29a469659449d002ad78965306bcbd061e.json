{"ast":null,"code":"// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst is = require('./is');\n\n/**\n * Weighting to apply when using contain/cover fit.\n * @member\n * @private\n */\nconst gravity = {\n  center: 0,\n  centre: 0,\n  north: 1,\n  east: 2,\n  south: 3,\n  west: 4,\n  northeast: 5,\n  southeast: 6,\n  southwest: 7,\n  northwest: 8\n};\n\n/**\n * Position to apply when using contain/cover fit.\n * @member\n * @private\n */\nconst position = {\n  top: 1,\n  right: 2,\n  bottom: 3,\n  left: 4,\n  'right top': 5,\n  'right bottom': 6,\n  'left bottom': 7,\n  'left top': 8\n};\n\n/**\n * How to extend the image.\n * @member\n * @private\n */\nconst extendWith = {\n  background: 'background',\n  copy: 'copy',\n  repeat: 'repeat',\n  mirror: 'mirror'\n};\n\n/**\n * Strategies for automagic cover behaviour.\n * @member\n * @private\n */\nconst strategy = {\n  entropy: 16,\n  attention: 17\n};\n\n/**\n * Reduction kernels.\n * @member\n * @private\n */\nconst kernel = {\n  nearest: 'nearest',\n  cubic: 'cubic',\n  mitchell: 'mitchell',\n  lanczos2: 'lanczos2',\n  lanczos3: 'lanczos3'\n};\n\n/**\n * Methods by which an image can be resized to fit the provided dimensions.\n * @member\n * @private\n */\nconst fit = {\n  contain: 'contain',\n  cover: 'cover',\n  fill: 'fill',\n  inside: 'inside',\n  outside: 'outside'\n};\n\n/**\n * Map external fit property to internal canvas property.\n * @member\n * @private\n */\nconst mapFitToCanvas = {\n  contain: 'embed',\n  cover: 'crop',\n  fill: 'ignore_aspect',\n  inside: 'max',\n  outside: 'min'\n};\n\n/**\n * @private\n */\nfunction isRotationExpected(options) {\n  return options.angle % 360 !== 0 || options.useExifOrientation === true || options.rotationAngle !== 0;\n}\n\n/**\n * @private\n */\nfunction isResizeExpected(options) {\n  return options.width !== -1 || options.height !== -1;\n}\n\n/**\n * Resize image to `width`, `height` or `width x height`.\n *\n * When both a `width` and `height` are provided, the possible methods by which the image should **fit** these are:\n * - `cover`: (default) Preserving aspect ratio, attempt to ensure the image covers both provided dimensions by cropping/clipping to fit.\n * - `contain`: Preserving aspect ratio, contain within both provided dimensions using \"letterboxing\" where necessary.\n * - `fill`: Ignore the aspect ratio of the input and stretch to both provided dimensions.\n * - `inside`: Preserving aspect ratio, resize the image to be as large as possible while ensuring its dimensions are less than or equal to both those specified.\n * - `outside`: Preserving aspect ratio, resize the image to be as small as possible while ensuring its dimensions are greater than or equal to both those specified.\n *\n * Some of these values are based on the [object-fit](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) CSS property.\n *\n * <img alt=\"Examples of various values for the fit property when resizing\" width=\"100%\" style=\"aspect-ratio: 998/243\" src=\"https://cdn.jsdelivr.net/gh/lovell/sharp@main/docs/image/api-resize-fit.png\">\n *\n * When using a **fit** of `cover` or `contain`, the default **position** is `centre`. Other options are:\n * - `sharp.position`: `top`, `right top`, `right`, `right bottom`, `bottom`, `left bottom`, `left`, `left top`.\n * - `sharp.gravity`: `north`, `northeast`, `east`, `southeast`, `south`, `southwest`, `west`, `northwest`, `center` or `centre`.\n * - `sharp.strategy`: `cover` only, dynamically crop using either the `entropy` or `attention` strategy.\n *\n * Some of these values are based on the [object-position](https://developer.mozilla.org/en-US/docs/Web/CSS/object-position) CSS property.\n *\n * The experimental strategy-based approach resizes so one dimension is at its target length\n * then repeatedly ranks edge regions, discarding the edge with the lowest score based on the selected strategy.\n * - `entropy`: focus on the region with the highest [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29).\n * - `attention`: focus on the region with the highest luminance frequency, colour saturation and presence of skin tones.\n *\n * Possible interpolation kernels are:\n * - `nearest`: Use [nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation).\n * - `cubic`: Use a [Catmull-Rom spline](https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline).\n * - `mitchell`: Use a [Mitchell-Netravali spline](https://www.cs.utexas.edu/~fussell/courses/cs384g-fall2013/lectures/mitchell/Mitchell.pdf).\n * - `lanczos2`: Use a [Lanczos kernel](https://en.wikipedia.org/wiki/Lanczos_resampling#Lanczos_kernel) with `a=2`.\n * - `lanczos3`: Use a Lanczos kernel with `a=3` (the default).\n *\n * Only one resize can occur per pipeline.\n * Previous calls to `resize` in the same pipeline will be ignored.\n *\n * @example\n * sharp(input)\n *   .resize({ width: 100 })\n *   .toBuffer()\n *   .then(data => {\n *     // 100 pixels wide, auto-scaled height\n *   });\n *\n * @example\n * sharp(input)\n *   .resize({ height: 100 })\n *   .toBuffer()\n *   .then(data => {\n *     // 100 pixels high, auto-scaled width\n *   });\n *\n * @example\n * sharp(input)\n *   .resize(200, 300, {\n *     kernel: sharp.kernel.nearest,\n *     fit: 'contain',\n *     position: 'right top',\n *     background: { r: 255, g: 255, b: 255, alpha: 0.5 }\n *   })\n *   .toFile('output.png')\n *   .then(() => {\n *     // output.png is a 200 pixels wide and 300 pixels high image\n *     // containing a nearest-neighbour scaled version\n *     // contained within the north-east corner of a semi-transparent white canvas\n *   });\n *\n * @example\n * const transformer = sharp()\n *   .resize({\n *     width: 200,\n *     height: 200,\n *     fit: sharp.fit.cover,\n *     position: sharp.strategy.entropy\n *   });\n * // Read image data from readableStream\n * // Write 200px square auto-cropped image data to writableStream\n * readableStream\n *   .pipe(transformer)\n *   .pipe(writableStream);\n *\n * @example\n * sharp(input)\n *   .resize(200, 200, {\n *     fit: sharp.fit.inside,\n *     withoutEnlargement: true\n *   })\n *   .toFormat('jpeg')\n *   .toBuffer()\n *   .then(function(outputBuffer) {\n *     // outputBuffer contains JPEG image data\n *     // no wider and no higher than 200 pixels\n *     // and no larger than the input image\n *   });\n *\n * @example\n * sharp(input)\n *   .resize(200, 200, {\n *     fit: sharp.fit.outside,\n *     withoutReduction: true\n *   })\n *   .toFormat('jpeg')\n *   .toBuffer()\n *   .then(function(outputBuffer) {\n *     // outputBuffer contains JPEG image data\n *     // of at least 200 pixels wide and 200 pixels high while maintaining aspect ratio\n *     // and no smaller than the input image\n *   });\n *\n * @example\n * const scaleByHalf = await sharp(input)\n *   .metadata()\n *   .then(({ width }) => sharp(input)\n *     .resize(Math.round(width * 0.5))\n *     .toBuffer()\n *   );\n *\n * @param {number} [width] - How many pixels wide the resultant image should be. Use `null` or `undefined` to auto-scale the width to match the height.\n * @param {number} [height] - How many pixels high the resultant image should be. Use `null` or `undefined` to auto-scale the height to match the width.\n * @param {Object} [options]\n * @param {number} [options.width] - An alternative means of specifying `width`. If both are present this takes priority.\n * @param {number} [options.height] - An alternative means of specifying `height`. If both are present this takes priority.\n * @param {String} [options.fit='cover'] - How the image should be resized/cropped to fit the target dimension(s), one of `cover`, `contain`, `fill`, `inside` or `outside`.\n * @param {String} [options.position='centre'] - A position, gravity or strategy to use when `fit` is `cover` or `contain`.\n * @param {String|Object} [options.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour when `fit` is `contain`, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.\n * @param {String} [options.kernel='lanczos3'] - The kernel to use for image reduction. Use the `fastShrinkOnLoad` option to control kernel vs shrink-on-load.\n * @param {Boolean} [options.withoutEnlargement=false] - Do not scale up if the width *or* height are already less than the target dimensions, equivalent to GraphicsMagick's `>` geometry option. This may result in output dimensions smaller than the target dimensions.\n * @param {Boolean} [options.withoutReduction=false] - Do not scale down if the width *or* height are already greater than the target dimensions, equivalent to GraphicsMagick's `<` geometry option. This may still result in a crop to reach the target dimensions.\n * @param {Boolean} [options.fastShrinkOnLoad=true] - Take greater advantage of the JPEG and WebP shrink-on-load feature, which can lead to a slight moirÃ© pattern or round-down of an auto-scaled dimension.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction resize(widthOrOptions, height, options) {\n  if (isResizeExpected(this.options)) {\n    this.options.debuglog('ignoring previous resize options');\n  }\n  if (is.defined(widthOrOptions)) {\n    if (is.object(widthOrOptions) && !is.defined(options)) {\n      options = widthOrOptions;\n    } else if (is.integer(widthOrOptions) && widthOrOptions > 0) {\n      this.options.width = widthOrOptions;\n    } else {\n      throw is.invalidParameterError('width', 'positive integer', widthOrOptions);\n    }\n  } else {\n    this.options.width = -1;\n  }\n  if (is.defined(height)) {\n    if (is.integer(height) && height > 0) {\n      this.options.height = height;\n    } else {\n      throw is.invalidParameterError('height', 'positive integer', height);\n    }\n  } else {\n    this.options.height = -1;\n  }\n  if (is.object(options)) {\n    // Width\n    if (is.defined(options.width)) {\n      if (is.integer(options.width) && options.width > 0) {\n        this.options.width = options.width;\n      } else {\n        throw is.invalidParameterError('width', 'positive integer', options.width);\n      }\n    }\n    // Height\n    if (is.defined(options.height)) {\n      if (is.integer(options.height) && options.height > 0) {\n        this.options.height = options.height;\n      } else {\n        throw is.invalidParameterError('height', 'positive integer', options.height);\n      }\n    }\n    // Fit\n    if (is.defined(options.fit)) {\n      const canvas = mapFitToCanvas[options.fit];\n      if (is.string(canvas)) {\n        this.options.canvas = canvas;\n      } else {\n        throw is.invalidParameterError('fit', 'valid fit', options.fit);\n      }\n    }\n    // Position\n    if (is.defined(options.position)) {\n      const pos = is.integer(options.position) ? options.position : strategy[options.position] || position[options.position] || gravity[options.position];\n      if (is.integer(pos) && (is.inRange(pos, 0, 8) || is.inRange(pos, 16, 17))) {\n        this.options.position = pos;\n      } else {\n        throw is.invalidParameterError('position', 'valid position/gravity/strategy', options.position);\n      }\n    }\n    // Background\n    this._setBackgroundColourOption('resizeBackground', options.background);\n    // Kernel\n    if (is.defined(options.kernel)) {\n      if (is.string(kernel[options.kernel])) {\n        this.options.kernel = kernel[options.kernel];\n      } else {\n        throw is.invalidParameterError('kernel', 'valid kernel name', options.kernel);\n      }\n    }\n    // Without enlargement\n    if (is.defined(options.withoutEnlargement)) {\n      this._setBooleanOption('withoutEnlargement', options.withoutEnlargement);\n    }\n    // Without reduction\n    if (is.defined(options.withoutReduction)) {\n      this._setBooleanOption('withoutReduction', options.withoutReduction);\n    }\n    // Shrink on load\n    if (is.defined(options.fastShrinkOnLoad)) {\n      this._setBooleanOption('fastShrinkOnLoad', options.fastShrinkOnLoad);\n    }\n  }\n  if (isRotationExpected(this.options) && isResizeExpected(this.options)) {\n    this.options.rotateBeforePreExtract = true;\n  }\n  return this;\n}\n\n/**\n * Extend / pad / extrude one or more edges of the image with either\n * the provided background colour or pixels derived from the image.\n * This operation will always occur after resizing and extraction, if any.\n *\n * @example\n * // Resize to 140 pixels wide, then add 10 transparent pixels\n * // to the top, left and right edges and 20 to the bottom edge\n * sharp(input)\n *   .resize(140)\n *   .extend({\n *     top: 10,\n *     bottom: 20,\n *     left: 10,\n *     right: 10,\n *     background: { r: 0, g: 0, b: 0, alpha: 0 }\n *   })\n *   ...\n *\n* @example\n * // Add a row of 10 red pixels to the bottom\n * sharp(input)\n *   .extend({\n *     bottom: 10,\n *     background: 'red'\n *   })\n *   ...\n *\n * @example\n * // Extrude image by 8 pixels to the right, mirroring existing right hand edge\n * sharp(input)\n *   .extend({\n *     right: 8,\n *     background: 'mirror'\n *   })\n *   ...\n *\n * @param {(number|Object)} extend - single pixel count to add to all edges or an Object with per-edge counts\n * @param {number} [extend.top=0]\n * @param {number} [extend.left=0]\n * @param {number} [extend.bottom=0]\n * @param {number} [extend.right=0]\n * @param {String} [extend.extendWith='background'] - populate new pixels using this method, one of: background, copy, repeat, mirror.\n * @param {String|Object} [extend.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n*/\nfunction extend(extend) {\n  if (is.integer(extend) && extend > 0) {\n    this.options.extendTop = extend;\n    this.options.extendBottom = extend;\n    this.options.extendLeft = extend;\n    this.options.extendRight = extend;\n  } else if (is.object(extend)) {\n    if (is.defined(extend.top)) {\n      if (is.integer(extend.top) && extend.top >= 0) {\n        this.options.extendTop = extend.top;\n      } else {\n        throw is.invalidParameterError('top', 'positive integer', extend.top);\n      }\n    }\n    if (is.defined(extend.bottom)) {\n      if (is.integer(extend.bottom) && extend.bottom >= 0) {\n        this.options.extendBottom = extend.bottom;\n      } else {\n        throw is.invalidParameterError('bottom', 'positive integer', extend.bottom);\n      }\n    }\n    if (is.defined(extend.left)) {\n      if (is.integer(extend.left) && extend.left >= 0) {\n        this.options.extendLeft = extend.left;\n      } else {\n        throw is.invalidParameterError('left', 'positive integer', extend.left);\n      }\n    }\n    if (is.defined(extend.right)) {\n      if (is.integer(extend.right) && extend.right >= 0) {\n        this.options.extendRight = extend.right;\n      } else {\n        throw is.invalidParameterError('right', 'positive integer', extend.right);\n      }\n    }\n    this._setBackgroundColourOption('extendBackground', extend.background);\n    if (is.defined(extend.extendWith)) {\n      if (is.string(extendWith[extend.extendWith])) {\n        this.options.extendWith = extendWith[extend.extendWith];\n      } else {\n        throw is.invalidParameterError('extendWith', 'one of: background, copy, repeat, mirror', extend.extendWith);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('extend', 'integer or object', extend);\n  }\n  return this;\n}\n\n/**\n * Extract/crop a region of the image.\n *\n * - Use `extract` before `resize` for pre-resize extraction.\n * - Use `extract` after `resize` for post-resize extraction.\n * - Use `extract` before and after for both.\n *\n * @example\n * sharp(input)\n *   .extract({ left: left, top: top, width: width, height: height })\n *   .toFile(output, function(err) {\n *     // Extract a region of the input image, saving in the same format.\n *   });\n * @example\n * sharp(input)\n *   .extract({ left: leftOffsetPre, top: topOffsetPre, width: widthPre, height: heightPre })\n *   .resize(width, height)\n *   .extract({ left: leftOffsetPost, top: topOffsetPost, width: widthPost, height: heightPost })\n *   .toFile(output, function(err) {\n *     // Extract a region, resize, then extract from the resized image\n *   });\n *\n * @param {Object} options - describes the region to extract using integral pixel values\n * @param {number} options.left - zero-indexed offset from left edge\n * @param {number} options.top - zero-indexed offset from top edge\n * @param {number} options.width - width of region to extract\n * @param {number} options.height - height of region to extract\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction extract(options) {\n  const suffix = isResizeExpected(this.options) || this.options.widthPre !== -1 ? 'Post' : 'Pre';\n  if (this.options[`width${suffix}`] !== -1) {\n    this.options.debuglog('ignoring previous extract options');\n  }\n  ['left', 'top', 'width', 'height'].forEach(function (name) {\n    const value = options[name];\n    if (is.integer(value) && value >= 0) {\n      this.options[name + (name === 'left' || name === 'top' ? 'Offset' : '') + suffix] = value;\n    } else {\n      throw is.invalidParameterError(name, 'integer', value);\n    }\n  }, this);\n  // Ensure existing rotation occurs before pre-resize extraction\n  if (isRotationExpected(this.options) && !isResizeExpected(this.options)) {\n    if (this.options.widthPre === -1 || this.options.widthPost === -1) {\n      this.options.rotateBeforePreExtract = true;\n    }\n  }\n  return this;\n}\n\n/**\n * Trim pixels from all edges that contain values similar to the given background colour, which defaults to that of the top-left pixel.\n *\n * Images with an alpha channel will use the combined bounding box of alpha and non-alpha channels.\n *\n * If the result of this operation would trim an image to nothing then no change is made.\n *\n * The `info` response Object, obtained from callback of `.toFile()` or `.toBuffer()`,\n * will contain `trimOffsetLeft` and `trimOffsetTop` properties.\n *\n * @example\n * // Trim pixels with a colour similar to that of the top-left pixel.\n * sharp(input)\n *   .trim()\n *   .toFile(output, function(err, info) {\n *     ...\n *   });\n * @example\n * // Trim pixels with the exact same colour as that of the top-left pixel.\n * sharp(input)\n *   .trim(0)\n *   .toFile(output, function(err, info) {\n *     ...\n *   });\n * @example\n * // Trim only pixels with a similar colour to red.\n * sharp(input)\n *   .trim(\"#FF0000\")\n *   .toFile(output, function(err, info) {\n *     ...\n *   });\n * @example\n * // Trim all \"yellow-ish\" pixels, being more lenient with the higher threshold.\n * sharp(input)\n *   .trim({\n *     background: \"yellow\",\n *     threshold: 42,\n *   })\n *   .toFile(output, function(err, info) {\n *     ...\n *   });\n *\n * @param {string|number|Object} trim - the specific background colour to trim, the threshold for doing so or an Object with both.\n * @param {string|Object} [trim.background='top-left pixel'] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to that of the top-left pixel.\n * @param {number} [trim.threshold=10] - the allowed difference from the above colour, a positive number.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction trim(trim) {\n  if (!is.defined(trim)) {\n    this.options.trimThreshold = 10;\n  } else if (is.string(trim)) {\n    this._setBackgroundColourOption('trimBackground', trim);\n    this.options.trimThreshold = 10;\n  } else if (is.number(trim)) {\n    if (trim >= 0) {\n      this.options.trimThreshold = trim;\n    } else {\n      throw is.invalidParameterError('threshold', 'positive number', trim);\n    }\n  } else if (is.object(trim)) {\n    this._setBackgroundColourOption('trimBackground', trim.background);\n    if (!is.defined(trim.threshold)) {\n      this.options.trimThreshold = 10;\n    } else if (is.number(trim.threshold) && trim.threshold >= 0) {\n      this.options.trimThreshold = trim.threshold;\n    } else {\n      throw is.invalidParameterError('threshold', 'positive number', trim);\n    }\n  } else {\n    throw is.invalidParameterError('trim', 'string, number or object', trim);\n  }\n  if (isRotationExpected(this.options)) {\n    this.options.rotateBeforePreExtract = true;\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with resize-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    resize,\n    extend,\n    extract,\n    trim\n  });\n  // Class attributes\n  Sharp.gravity = gravity;\n  Sharp.strategy = strategy;\n  Sharp.kernel = kernel;\n  Sharp.fit = fit;\n  Sharp.position = position;\n};","map":{"version":3,"names":["is","require","gravity","center","centre","north","east","south","west","northeast","southeast","southwest","northwest","position","top","right","bottom","left","extendWith","background","copy","repeat","mirror","strategy","entropy","attention","kernel","nearest","cubic","mitchell","lanczos2","lanczos3","fit","contain","cover","fill","inside","outside","mapFitToCanvas","isRotationExpected","options","angle","useExifOrientation","rotationAngle","isResizeExpected","width","height","resize","widthOrOptions","debuglog","defined","object","integer","invalidParameterError","canvas","string","pos","inRange","_setBackgroundColourOption","withoutEnlargement","_setBooleanOption","withoutReduction","fastShrinkOnLoad","rotateBeforePreExtract","extend","extendTop","extendBottom","extendLeft","extendRight","extract","suffix","widthPre","forEach","name","value","widthPost","trim","trimThreshold","number","threshold","module","exports","Sharp","Object","assign","prototype"],"sources":["/Users/divyakulkarni/Desktop/IAMW/image-annotation-measurement/node_modules/sharp/lib/resize.js"],"sourcesContent":["// Copyright 2013 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst is = require('./is');\n\n/**\n * Weighting to apply when using contain/cover fit.\n * @member\n * @private\n */\nconst gravity = {\n  center: 0,\n  centre: 0,\n  north: 1,\n  east: 2,\n  south: 3,\n  west: 4,\n  northeast: 5,\n  southeast: 6,\n  southwest: 7,\n  northwest: 8\n};\n\n/**\n * Position to apply when using contain/cover fit.\n * @member\n * @private\n */\nconst position = {\n  top: 1,\n  right: 2,\n  bottom: 3,\n  left: 4,\n  'right top': 5,\n  'right bottom': 6,\n  'left bottom': 7,\n  'left top': 8\n};\n\n/**\n * How to extend the image.\n * @member\n * @private\n */\nconst extendWith = {\n  background: 'background',\n  copy: 'copy',\n  repeat: 'repeat',\n  mirror: 'mirror'\n};\n\n/**\n * Strategies for automagic cover behaviour.\n * @member\n * @private\n */\nconst strategy = {\n  entropy: 16,\n  attention: 17\n};\n\n/**\n * Reduction kernels.\n * @member\n * @private\n */\nconst kernel = {\n  nearest: 'nearest',\n  cubic: 'cubic',\n  mitchell: 'mitchell',\n  lanczos2: 'lanczos2',\n  lanczos3: 'lanczos3'\n};\n\n/**\n * Methods by which an image can be resized to fit the provided dimensions.\n * @member\n * @private\n */\nconst fit = {\n  contain: 'contain',\n  cover: 'cover',\n  fill: 'fill',\n  inside: 'inside',\n  outside: 'outside'\n};\n\n/**\n * Map external fit property to internal canvas property.\n * @member\n * @private\n */\nconst mapFitToCanvas = {\n  contain: 'embed',\n  cover: 'crop',\n  fill: 'ignore_aspect',\n  inside: 'max',\n  outside: 'min'\n};\n\n/**\n * @private\n */\nfunction isRotationExpected (options) {\n  return (options.angle % 360) !== 0 || options.useExifOrientation === true || options.rotationAngle !== 0;\n}\n\n/**\n * @private\n */\nfunction isResizeExpected (options) {\n  return options.width !== -1 || options.height !== -1;\n}\n\n/**\n * Resize image to `width`, `height` or `width x height`.\n *\n * When both a `width` and `height` are provided, the possible methods by which the image should **fit** these are:\n * - `cover`: (default) Preserving aspect ratio, attempt to ensure the image covers both provided dimensions by cropping/clipping to fit.\n * - `contain`: Preserving aspect ratio, contain within both provided dimensions using \"letterboxing\" where necessary.\n * - `fill`: Ignore the aspect ratio of the input and stretch to both provided dimensions.\n * - `inside`: Preserving aspect ratio, resize the image to be as large as possible while ensuring its dimensions are less than or equal to both those specified.\n * - `outside`: Preserving aspect ratio, resize the image to be as small as possible while ensuring its dimensions are greater than or equal to both those specified.\n *\n * Some of these values are based on the [object-fit](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) CSS property.\n *\n * <img alt=\"Examples of various values for the fit property when resizing\" width=\"100%\" style=\"aspect-ratio: 998/243\" src=\"https://cdn.jsdelivr.net/gh/lovell/sharp@main/docs/image/api-resize-fit.png\">\n *\n * When using a **fit** of `cover` or `contain`, the default **position** is `centre`. Other options are:\n * - `sharp.position`: `top`, `right top`, `right`, `right bottom`, `bottom`, `left bottom`, `left`, `left top`.\n * - `sharp.gravity`: `north`, `northeast`, `east`, `southeast`, `south`, `southwest`, `west`, `northwest`, `center` or `centre`.\n * - `sharp.strategy`: `cover` only, dynamically crop using either the `entropy` or `attention` strategy.\n *\n * Some of these values are based on the [object-position](https://developer.mozilla.org/en-US/docs/Web/CSS/object-position) CSS property.\n *\n * The experimental strategy-based approach resizes so one dimension is at its target length\n * then repeatedly ranks edge regions, discarding the edge with the lowest score based on the selected strategy.\n * - `entropy`: focus on the region with the highest [Shannon entropy](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29).\n * - `attention`: focus on the region with the highest luminance frequency, colour saturation and presence of skin tones.\n *\n * Possible interpolation kernels are:\n * - `nearest`: Use [nearest neighbour interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation).\n * - `cubic`: Use a [Catmull-Rom spline](https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline).\n * - `mitchell`: Use a [Mitchell-Netravali spline](https://www.cs.utexas.edu/~fussell/courses/cs384g-fall2013/lectures/mitchell/Mitchell.pdf).\n * - `lanczos2`: Use a [Lanczos kernel](https://en.wikipedia.org/wiki/Lanczos_resampling#Lanczos_kernel) with `a=2`.\n * - `lanczos3`: Use a Lanczos kernel with `a=3` (the default).\n *\n * Only one resize can occur per pipeline.\n * Previous calls to `resize` in the same pipeline will be ignored.\n *\n * @example\n * sharp(input)\n *   .resize({ width: 100 })\n *   .toBuffer()\n *   .then(data => {\n *     // 100 pixels wide, auto-scaled height\n *   });\n *\n * @example\n * sharp(input)\n *   .resize({ height: 100 })\n *   .toBuffer()\n *   .then(data => {\n *     // 100 pixels high, auto-scaled width\n *   });\n *\n * @example\n * sharp(input)\n *   .resize(200, 300, {\n *     kernel: sharp.kernel.nearest,\n *     fit: 'contain',\n *     position: 'right top',\n *     background: { r: 255, g: 255, b: 255, alpha: 0.5 }\n *   })\n *   .toFile('output.png')\n *   .then(() => {\n *     // output.png is a 200 pixels wide and 300 pixels high image\n *     // containing a nearest-neighbour scaled version\n *     // contained within the north-east corner of a semi-transparent white canvas\n *   });\n *\n * @example\n * const transformer = sharp()\n *   .resize({\n *     width: 200,\n *     height: 200,\n *     fit: sharp.fit.cover,\n *     position: sharp.strategy.entropy\n *   });\n * // Read image data from readableStream\n * // Write 200px square auto-cropped image data to writableStream\n * readableStream\n *   .pipe(transformer)\n *   .pipe(writableStream);\n *\n * @example\n * sharp(input)\n *   .resize(200, 200, {\n *     fit: sharp.fit.inside,\n *     withoutEnlargement: true\n *   })\n *   .toFormat('jpeg')\n *   .toBuffer()\n *   .then(function(outputBuffer) {\n *     // outputBuffer contains JPEG image data\n *     // no wider and no higher than 200 pixels\n *     // and no larger than the input image\n *   });\n *\n * @example\n * sharp(input)\n *   .resize(200, 200, {\n *     fit: sharp.fit.outside,\n *     withoutReduction: true\n *   })\n *   .toFormat('jpeg')\n *   .toBuffer()\n *   .then(function(outputBuffer) {\n *     // outputBuffer contains JPEG image data\n *     // of at least 200 pixels wide and 200 pixels high while maintaining aspect ratio\n *     // and no smaller than the input image\n *   });\n *\n * @example\n * const scaleByHalf = await sharp(input)\n *   .metadata()\n *   .then(({ width }) => sharp(input)\n *     .resize(Math.round(width * 0.5))\n *     .toBuffer()\n *   );\n *\n * @param {number} [width] - How many pixels wide the resultant image should be. Use `null` or `undefined` to auto-scale the width to match the height.\n * @param {number} [height] - How many pixels high the resultant image should be. Use `null` or `undefined` to auto-scale the height to match the width.\n * @param {Object} [options]\n * @param {number} [options.width] - An alternative means of specifying `width`. If both are present this takes priority.\n * @param {number} [options.height] - An alternative means of specifying `height`. If both are present this takes priority.\n * @param {String} [options.fit='cover'] - How the image should be resized/cropped to fit the target dimension(s), one of `cover`, `contain`, `fill`, `inside` or `outside`.\n * @param {String} [options.position='centre'] - A position, gravity or strategy to use when `fit` is `cover` or `contain`.\n * @param {String|Object} [options.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour when `fit` is `contain`, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.\n * @param {String} [options.kernel='lanczos3'] - The kernel to use for image reduction. Use the `fastShrinkOnLoad` option to control kernel vs shrink-on-load.\n * @param {Boolean} [options.withoutEnlargement=false] - Do not scale up if the width *or* height are already less than the target dimensions, equivalent to GraphicsMagick's `>` geometry option. This may result in output dimensions smaller than the target dimensions.\n * @param {Boolean} [options.withoutReduction=false] - Do not scale down if the width *or* height are already greater than the target dimensions, equivalent to GraphicsMagick's `<` geometry option. This may still result in a crop to reach the target dimensions.\n * @param {Boolean} [options.fastShrinkOnLoad=true] - Take greater advantage of the JPEG and WebP shrink-on-load feature, which can lead to a slight moirÃ© pattern or round-down of an auto-scaled dimension.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction resize (widthOrOptions, height, options) {\n  if (isResizeExpected(this.options)) {\n    this.options.debuglog('ignoring previous resize options');\n  }\n  if (is.defined(widthOrOptions)) {\n    if (is.object(widthOrOptions) && !is.defined(options)) {\n      options = widthOrOptions;\n    } else if (is.integer(widthOrOptions) && widthOrOptions > 0) {\n      this.options.width = widthOrOptions;\n    } else {\n      throw is.invalidParameterError('width', 'positive integer', widthOrOptions);\n    }\n  } else {\n    this.options.width = -1;\n  }\n  if (is.defined(height)) {\n    if (is.integer(height) && height > 0) {\n      this.options.height = height;\n    } else {\n      throw is.invalidParameterError('height', 'positive integer', height);\n    }\n  } else {\n    this.options.height = -1;\n  }\n  if (is.object(options)) {\n    // Width\n    if (is.defined(options.width)) {\n      if (is.integer(options.width) && options.width > 0) {\n        this.options.width = options.width;\n      } else {\n        throw is.invalidParameterError('width', 'positive integer', options.width);\n      }\n    }\n    // Height\n    if (is.defined(options.height)) {\n      if (is.integer(options.height) && options.height > 0) {\n        this.options.height = options.height;\n      } else {\n        throw is.invalidParameterError('height', 'positive integer', options.height);\n      }\n    }\n    // Fit\n    if (is.defined(options.fit)) {\n      const canvas = mapFitToCanvas[options.fit];\n      if (is.string(canvas)) {\n        this.options.canvas = canvas;\n      } else {\n        throw is.invalidParameterError('fit', 'valid fit', options.fit);\n      }\n    }\n    // Position\n    if (is.defined(options.position)) {\n      const pos = is.integer(options.position)\n        ? options.position\n        : strategy[options.position] || position[options.position] || gravity[options.position];\n      if (is.integer(pos) && (is.inRange(pos, 0, 8) || is.inRange(pos, 16, 17))) {\n        this.options.position = pos;\n      } else {\n        throw is.invalidParameterError('position', 'valid position/gravity/strategy', options.position);\n      }\n    }\n    // Background\n    this._setBackgroundColourOption('resizeBackground', options.background);\n    // Kernel\n    if (is.defined(options.kernel)) {\n      if (is.string(kernel[options.kernel])) {\n        this.options.kernel = kernel[options.kernel];\n      } else {\n        throw is.invalidParameterError('kernel', 'valid kernel name', options.kernel);\n      }\n    }\n    // Without enlargement\n    if (is.defined(options.withoutEnlargement)) {\n      this._setBooleanOption('withoutEnlargement', options.withoutEnlargement);\n    }\n    // Without reduction\n    if (is.defined(options.withoutReduction)) {\n      this._setBooleanOption('withoutReduction', options.withoutReduction);\n    }\n    // Shrink on load\n    if (is.defined(options.fastShrinkOnLoad)) {\n      this._setBooleanOption('fastShrinkOnLoad', options.fastShrinkOnLoad);\n    }\n  }\n  if (isRotationExpected(this.options) && isResizeExpected(this.options)) {\n    this.options.rotateBeforePreExtract = true;\n  }\n  return this;\n}\n\n/**\n * Extend / pad / extrude one or more edges of the image with either\n * the provided background colour or pixels derived from the image.\n * This operation will always occur after resizing and extraction, if any.\n *\n * @example\n * // Resize to 140 pixels wide, then add 10 transparent pixels\n * // to the top, left and right edges and 20 to the bottom edge\n * sharp(input)\n *   .resize(140)\n *   .extend({\n *     top: 10,\n *     bottom: 20,\n *     left: 10,\n *     right: 10,\n *     background: { r: 0, g: 0, b: 0, alpha: 0 }\n *   })\n *   ...\n *\n* @example\n * // Add a row of 10 red pixels to the bottom\n * sharp(input)\n *   .extend({\n *     bottom: 10,\n *     background: 'red'\n *   })\n *   ...\n *\n * @example\n * // Extrude image by 8 pixels to the right, mirroring existing right hand edge\n * sharp(input)\n *   .extend({\n *     right: 8,\n *     background: 'mirror'\n *   })\n *   ...\n *\n * @param {(number|Object)} extend - single pixel count to add to all edges or an Object with per-edge counts\n * @param {number} [extend.top=0]\n * @param {number} [extend.left=0]\n * @param {number} [extend.bottom=0]\n * @param {number} [extend.right=0]\n * @param {String} [extend.extendWith='background'] - populate new pixels using this method, one of: background, copy, repeat, mirror.\n * @param {String|Object} [extend.background={r: 0, g: 0, b: 0, alpha: 1}] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to black without transparency.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n*/\nfunction extend (extend) {\n  if (is.integer(extend) && extend > 0) {\n    this.options.extendTop = extend;\n    this.options.extendBottom = extend;\n    this.options.extendLeft = extend;\n    this.options.extendRight = extend;\n  } else if (is.object(extend)) {\n    if (is.defined(extend.top)) {\n      if (is.integer(extend.top) && extend.top >= 0) {\n        this.options.extendTop = extend.top;\n      } else {\n        throw is.invalidParameterError('top', 'positive integer', extend.top);\n      }\n    }\n    if (is.defined(extend.bottom)) {\n      if (is.integer(extend.bottom) && extend.bottom >= 0) {\n        this.options.extendBottom = extend.bottom;\n      } else {\n        throw is.invalidParameterError('bottom', 'positive integer', extend.bottom);\n      }\n    }\n    if (is.defined(extend.left)) {\n      if (is.integer(extend.left) && extend.left >= 0) {\n        this.options.extendLeft = extend.left;\n      } else {\n        throw is.invalidParameterError('left', 'positive integer', extend.left);\n      }\n    }\n    if (is.defined(extend.right)) {\n      if (is.integer(extend.right) && extend.right >= 0) {\n        this.options.extendRight = extend.right;\n      } else {\n        throw is.invalidParameterError('right', 'positive integer', extend.right);\n      }\n    }\n    this._setBackgroundColourOption('extendBackground', extend.background);\n    if (is.defined(extend.extendWith)) {\n      if (is.string(extendWith[extend.extendWith])) {\n        this.options.extendWith = extendWith[extend.extendWith];\n      } else {\n        throw is.invalidParameterError('extendWith', 'one of: background, copy, repeat, mirror', extend.extendWith);\n      }\n    }\n  } else {\n    throw is.invalidParameterError('extend', 'integer or object', extend);\n  }\n  return this;\n}\n\n/**\n * Extract/crop a region of the image.\n *\n * - Use `extract` before `resize` for pre-resize extraction.\n * - Use `extract` after `resize` for post-resize extraction.\n * - Use `extract` before and after for both.\n *\n * @example\n * sharp(input)\n *   .extract({ left: left, top: top, width: width, height: height })\n *   .toFile(output, function(err) {\n *     // Extract a region of the input image, saving in the same format.\n *   });\n * @example\n * sharp(input)\n *   .extract({ left: leftOffsetPre, top: topOffsetPre, width: widthPre, height: heightPre })\n *   .resize(width, height)\n *   .extract({ left: leftOffsetPost, top: topOffsetPost, width: widthPost, height: heightPost })\n *   .toFile(output, function(err) {\n *     // Extract a region, resize, then extract from the resized image\n *   });\n *\n * @param {Object} options - describes the region to extract using integral pixel values\n * @param {number} options.left - zero-indexed offset from left edge\n * @param {number} options.top - zero-indexed offset from top edge\n * @param {number} options.width - width of region to extract\n * @param {number} options.height - height of region to extract\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction extract (options) {\n  const suffix = isResizeExpected(this.options) || this.options.widthPre !== -1 ? 'Post' : 'Pre';\n  if (this.options[`width${suffix}`] !== -1) {\n    this.options.debuglog('ignoring previous extract options');\n  }\n  ['left', 'top', 'width', 'height'].forEach(function (name) {\n    const value = options[name];\n    if (is.integer(value) && value >= 0) {\n      this.options[name + (name === 'left' || name === 'top' ? 'Offset' : '') + suffix] = value;\n    } else {\n      throw is.invalidParameterError(name, 'integer', value);\n    }\n  }, this);\n  // Ensure existing rotation occurs before pre-resize extraction\n  if (isRotationExpected(this.options) && !isResizeExpected(this.options)) {\n    if (this.options.widthPre === -1 || this.options.widthPost === -1) {\n      this.options.rotateBeforePreExtract = true;\n    }\n  }\n  return this;\n}\n\n/**\n * Trim pixels from all edges that contain values similar to the given background colour, which defaults to that of the top-left pixel.\n *\n * Images with an alpha channel will use the combined bounding box of alpha and non-alpha channels.\n *\n * If the result of this operation would trim an image to nothing then no change is made.\n *\n * The `info` response Object, obtained from callback of `.toFile()` or `.toBuffer()`,\n * will contain `trimOffsetLeft` and `trimOffsetTop` properties.\n *\n * @example\n * // Trim pixels with a colour similar to that of the top-left pixel.\n * sharp(input)\n *   .trim()\n *   .toFile(output, function(err, info) {\n *     ...\n *   });\n * @example\n * // Trim pixels with the exact same colour as that of the top-left pixel.\n * sharp(input)\n *   .trim(0)\n *   .toFile(output, function(err, info) {\n *     ...\n *   });\n * @example\n * // Trim only pixels with a similar colour to red.\n * sharp(input)\n *   .trim(\"#FF0000\")\n *   .toFile(output, function(err, info) {\n *     ...\n *   });\n * @example\n * // Trim all \"yellow-ish\" pixels, being more lenient with the higher threshold.\n * sharp(input)\n *   .trim({\n *     background: \"yellow\",\n *     threshold: 42,\n *   })\n *   .toFile(output, function(err, info) {\n *     ...\n *   });\n *\n * @param {string|number|Object} trim - the specific background colour to trim, the threshold for doing so or an Object with both.\n * @param {string|Object} [trim.background='top-left pixel'] - background colour, parsed by the [color](https://www.npmjs.org/package/color) module, defaults to that of the top-left pixel.\n * @param {number} [trim.threshold=10] - the allowed difference from the above colour, a positive number.\n * @returns {Sharp}\n * @throws {Error} Invalid parameters\n */\nfunction trim (trim) {\n  if (!is.defined(trim)) {\n    this.options.trimThreshold = 10;\n  } else if (is.string(trim)) {\n    this._setBackgroundColourOption('trimBackground', trim);\n    this.options.trimThreshold = 10;\n  } else if (is.number(trim)) {\n    if (trim >= 0) {\n      this.options.trimThreshold = trim;\n    } else {\n      throw is.invalidParameterError('threshold', 'positive number', trim);\n    }\n  } else if (is.object(trim)) {\n    this._setBackgroundColourOption('trimBackground', trim.background);\n    if (!is.defined(trim.threshold)) {\n      this.options.trimThreshold = 10;\n    } else if (is.number(trim.threshold) && trim.threshold >= 0) {\n      this.options.trimThreshold = trim.threshold;\n    } else {\n      throw is.invalidParameterError('threshold', 'positive number', trim);\n    }\n  } else {\n    throw is.invalidParameterError('trim', 'string, number or object', trim);\n  }\n  if (isRotationExpected(this.options)) {\n    this.options.rotateBeforePreExtract = true;\n  }\n  return this;\n}\n\n/**\n * Decorate the Sharp prototype with resize-related functions.\n * @private\n */\nmodule.exports = function (Sharp) {\n  Object.assign(Sharp.prototype, {\n    resize,\n    extend,\n    extract,\n    trim\n  });\n  // Class attributes\n  Sharp.gravity = gravity;\n  Sharp.strategy = strategy;\n  Sharp.kernel = kernel;\n  Sharp.fit = fit;\n  Sharp.position = position;\n};\n"],"mappings":"AAAA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,EAAE,GAAGC,OAAO,CAAC,MAAM,CAAC;;AAE1B;AACA;AACA;AACA;AACA;AACA,MAAMC,OAAO,GAAG;EACdC,MAAM,EAAE,CAAC;EACTC,MAAM,EAAE,CAAC;EACTC,KAAK,EAAE,CAAC;EACRC,IAAI,EAAE,CAAC;EACPC,KAAK,EAAE,CAAC;EACRC,IAAI,EAAE,CAAC;EACPC,SAAS,EAAE,CAAC;EACZC,SAAS,EAAE,CAAC;EACZC,SAAS,EAAE,CAAC;EACZC,SAAS,EAAE;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,QAAQ,GAAG;EACfC,GAAG,EAAE,CAAC;EACNC,KAAK,EAAE,CAAC;EACRC,MAAM,EAAE,CAAC;EACTC,IAAI,EAAE,CAAC;EACP,WAAW,EAAE,CAAC;EACd,cAAc,EAAE,CAAC;EACjB,aAAa,EAAE,CAAC;EAChB,UAAU,EAAE;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAG;EACjBC,UAAU,EAAE,YAAY;EACxBC,IAAI,EAAE,MAAM;EACZC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,QAAQ,GAAG;EACfC,OAAO,EAAE,EAAE;EACXC,SAAS,EAAE;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,MAAM,GAAG;EACbC,OAAO,EAAE,SAAS;EAClBC,KAAK,EAAE,OAAO;EACdC,QAAQ,EAAE,UAAU;EACpBC,QAAQ,EAAE,UAAU;EACpBC,QAAQ,EAAE;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,GAAG,GAAG;EACVC,OAAO,EAAE,SAAS;EAClBC,KAAK,EAAE,OAAO;EACdC,IAAI,EAAE,MAAM;EACZC,MAAM,EAAE,QAAQ;EAChBC,OAAO,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMC,cAAc,GAAG;EACrBL,OAAO,EAAE,OAAO;EAChBC,KAAK,EAAE,MAAM;EACbC,IAAI,EAAE,eAAe;EACrBC,MAAM,EAAE,KAAK;EACbC,OAAO,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA,SAASE,kBAAkBA,CAAEC,OAAO,EAAE;EACpC,OAAQA,OAAO,CAACC,KAAK,GAAG,GAAG,KAAM,CAAC,IAAID,OAAO,CAACE,kBAAkB,KAAK,IAAI,IAAIF,OAAO,CAACG,aAAa,KAAK,CAAC;AAC1G;;AAEA;AACA;AACA;AACA,SAASC,gBAAgBA,CAAEJ,OAAO,EAAE;EAClC,OAAOA,OAAO,CAACK,KAAK,KAAK,CAAC,CAAC,IAAIL,OAAO,CAACM,MAAM,KAAK,CAAC,CAAC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAAEC,cAAc,EAAEF,MAAM,EAAEN,OAAO,EAAE;EAChD,IAAII,gBAAgB,CAAC,IAAI,CAACJ,OAAO,CAAC,EAAE;IAClC,IAAI,CAACA,OAAO,CAACS,QAAQ,CAAC,kCAAkC,CAAC;EAC3D;EACA,IAAIjD,E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"},"metadata":{},"sourceType":"script","externalDependencies":[]}